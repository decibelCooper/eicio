// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: eicio.proto

/*
	Package model is a generated protocol buffer package.

	It is generated from these files:
		eicio.proto

	It has these top-level messages:
		EventHeader
		IntParams
		FloatParams
		StringParams
		Params
		Reference
		ParticleID
		MCParticle
		MCParticleCollection
		SimTrackerHit
		SimTrackerHitCollection
		TrackerRawData
		TrackerRawDataCollection
		TrackerData
		TrackerDataCollection
		TrackerHit
		TrackerHitCollection
		TrackerPulse
		TrackerPulseCollection
		TrackerHitPlane
		TrackerHitPlaneCollection
		TrackerHitZCylinder
		TrackerHitZCylinderCollection
		Track
		TrackCollection
		SimCalorimeterHit
		SimCalorimeterHitCollection
		RawCalorimeterHit
		RawCalorimeterHitCollection
		CalorimeterHit
		CalorimeterHitCollection
		Cluster
		ClusterCollection
		RecParticle
		RecParticleCollection
		Vertex
		VertexCollection
		Relation
		RelationCollection
*/
package model

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type EventHeader struct {
	Version            uint32                          `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	RunNumber          uint64                          `protobuf:"varint,2,opt,name=runNumber,proto3" json:"runNumber,omitempty"`
	EventNumber        uint64                          `protobuf:"varint,3,opt,name=eventNumber,proto3" json:"eventNumber,omitempty"`
	TimeStamp          uint64                          `protobuf:"varint,4,opt,name=timeStamp,proto3" json:"timeStamp,omitempty"`
	Detector           string                          `protobuf:"bytes,5,opt,name=detector,proto3" json:"detector,omitempty"`
	Params             *Params                         `protobuf:"bytes,6,opt,name=params" json:"params,omitempty"`
	PayloadCollections []*EventHeader_CollectionHeader `protobuf:"bytes,7,rep,name=payloadCollections" json:"payloadCollections,omitempty"`
	NUniqueIDs         uint32                          `protobuf:"varint,8,opt,name=nUniqueIDs,proto3" json:"nUniqueIDs,omitempty"`
	Description        string                          `protobuf:"bytes,16,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *EventHeader) Reset()                    { *m = EventHeader{} }
func (m *EventHeader) String() string            { return proto.CompactTextString(m) }
func (*EventHeader) ProtoMessage()               {}
func (*EventHeader) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{0} }

func (m *EventHeader) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *EventHeader) GetRunNumber() uint64 {
	if m != nil {
		return m.RunNumber
	}
	return 0
}

func (m *EventHeader) GetEventNumber() uint64 {
	if m != nil {
		return m.EventNumber
	}
	return 0
}

func (m *EventHeader) GetTimeStamp() uint64 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

func (m *EventHeader) GetDetector() string {
	if m != nil {
		return m.Detector
	}
	return ""
}

func (m *EventHeader) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *EventHeader) GetPayloadCollections() []*EventHeader_CollectionHeader {
	if m != nil {
		return m.PayloadCollections
	}
	return nil
}

func (m *EventHeader) GetNUniqueIDs() uint32 {
	if m != nil {
		return m.NUniqueIDs
	}
	return 0
}

func (m *EventHeader) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type EventHeader_CollectionHeader struct {
	Name        string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Id          uint32 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Type        string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	PayloadSize uint32 `protobuf:"varint,4,opt,name=payloadSize,proto3" json:"payloadSize,omitempty"`
}

func (m *EventHeader_CollectionHeader) Reset()         { *m = EventHeader_CollectionHeader{} }
func (m *EventHeader_CollectionHeader) String() string { return proto.CompactTextString(m) }
func (*EventHeader_CollectionHeader) ProtoMessage()    {}
func (*EventHeader_CollectionHeader) Descriptor() ([]byte, []int) {
	return fileDescriptorEicio, []int{0, 0}
}

func (m *EventHeader_CollectionHeader) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventHeader_CollectionHeader) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EventHeader_CollectionHeader) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *EventHeader_CollectionHeader) GetPayloadSize() uint32 {
	if m != nil {
		return m.PayloadSize
	}
	return 0
}

type IntParams struct {
	Array []int32 `protobuf:"varint,1,rep,packed,name=array" json:"array,omitempty"`
}

func (m *IntParams) Reset()                    { *m = IntParams{} }
func (m *IntParams) String() string            { return proto.CompactTextString(m) }
func (*IntParams) ProtoMessage()               {}
func (*IntParams) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{1} }

func (m *IntParams) GetArray() []int32 {
	if m != nil {
		return m.Array
	}
	return nil
}

type FloatParams struct {
	Array []float32 `protobuf:"fixed32,1,rep,packed,name=array" json:"array,omitempty"`
}

func (m *FloatParams) Reset()                    { *m = FloatParams{} }
func (m *FloatParams) String() string            { return proto.CompactTextString(m) }
func (*FloatParams) ProtoMessage()               {}
func (*FloatParams) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{2} }

func (m *FloatParams) GetArray() []float32 {
	if m != nil {
		return m.Array
	}
	return nil
}

type StringParams struct {
	Array []string `protobuf:"bytes,1,rep,name=array" json:"array,omitempty"`
}

func (m *StringParams) Reset()                    { *m = StringParams{} }
func (m *StringParams) String() string            { return proto.CompactTextString(m) }
func (*StringParams) ProtoMessage()               {}
func (*StringParams) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{3} }

func (m *StringParams) GetArray() []string {
	if m != nil {
		return m.Array
	}
	return nil
}

type Params struct {
	Ints    map[string]*IntParams    `protobuf:"bytes,1,rep,name=ints" json:"ints,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Floats  map[string]*FloatParams  `protobuf:"bytes,2,rep,name=floats" json:"floats,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Strings map[string]*StringParams `protobuf:"bytes,3,rep,name=strings" json:"strings,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Params) Reset()                    { *m = Params{} }
func (m *Params) String() string            { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()               {}
func (*Params) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{4} }

func (m *Params) GetInts() map[string]*IntParams {
	if m != nil {
		return m.Ints
	}
	return nil
}

func (m *Params) GetFloats() map[string]*FloatParams {
	if m != nil {
		return m.Floats
	}
	return nil
}

func (m *Params) GetStrings() map[string]*StringParams {
	if m != nil {
		return m.Strings
	}
	return nil
}

// References are required by the libraries, and should not be removed.
// However, more fields may be added.
type Reference struct {
	CollID  uint32 `protobuf:"varint,1,opt,name=collID,proto3" json:"collID,omitempty"`
	EntryID uint32 `protobuf:"varint,2,opt,name=entryID,proto3" json:"entryID,omitempty"`
}

func (m *Reference) Reset()                    { *m = Reference{} }
func (m *Reference) String() string            { return proto.CompactTextString(m) }
func (*Reference) ProtoMessage()               {}
func (*Reference) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{5} }

func (m *Reference) GetCollID() uint32 {
	if m != nil {
		return m.CollID
	}
	return 0
}

func (m *Reference) GetEntryID() uint32 {
	if m != nil {
		return m.EntryID
	}
	return 0
}

type ParticleID struct {
	Likelihood float32   `protobuf:"fixed32,1,opt,name=likelihood,proto3" json:"likelihood,omitempty"`
	Type       int32     `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	PDG        int32     `protobuf:"varint,3,opt,name=PDG,proto3" json:"PDG,omitempty"`
	AlgType    int32     `protobuf:"varint,4,opt,name=algType,proto3" json:"algType,omitempty"`
	Params     []float32 `protobuf:"fixed32,5,rep,packed,name=params" json:"params,omitempty"`
}

func (m *ParticleID) Reset()                    { *m = ParticleID{} }
func (m *ParticleID) String() string            { return proto.CompactTextString(m) }
func (*ParticleID) ProtoMessage()               {}
func (*ParticleID) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{6} }

func (m *ParticleID) GetLikelihood() float32 {
	if m != nil {
		return m.Likelihood
	}
	return 0
}

func (m *ParticleID) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ParticleID) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *ParticleID) GetAlgType() int32 {
	if m != nil {
		return m.AlgType
	}
	return 0
}

func (m *ParticleID) GetParams() []float32 {
	if m != nil {
		return m.Params
	}
	return nil
}

type MCParticle struct {
	Id        uint32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Parents   []*Reference `protobuf:"bytes,2,rep,name=parents" json:"parents,omitempty"`
	Children  []*Reference `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
	PDG       int32        `protobuf:"varint,4,opt,name=PDG,proto3" json:"PDG,omitempty"`
	Vertex    []float64    `protobuf:"fixed64,5,rep,packed,name=vertex" json:"vertex,omitempty"`
	Time      float32      `protobuf:"fixed32,6,opt,name=time,proto3" json:"time,omitempty"`
	P         []float64    `protobuf:"fixed64,7,rep,packed,name=p" json:"p,omitempty"`
	Mass      float64      `protobuf:"fixed64,8,opt,name=mass,proto3" json:"mass,omitempty"`
	Charge    float32      `protobuf:"fixed32,9,opt,name=charge,proto3" json:"charge,omitempty"`
	PEndPoint []float64    `protobuf:"fixed64,10,rep,packed,name=PEndPoint" json:"PEndPoint,omitempty"`
	Spin      []float32    `protobuf:"fixed32,11,rep,packed,name=spin" json:"spin,omitempty"`
	ColorFlow []int32      `protobuf:"varint,12,rep,packed,name=colorFlow" json:"colorFlow,omitempty"`
	GenStatus int32        `protobuf:"varint,13,opt,name=genStatus,proto3" json:"genStatus,omitempty"`
	SimStatus uint32       `protobuf:"varint,14,opt,name=simStatus,proto3" json:"simStatus,omitempty"`
}

func (m *MCParticle) Reset()                    { *m = MCParticle{} }
func (m *MCParticle) String() string            { return proto.CompactTextString(m) }
func (*MCParticle) ProtoMessage()               {}
func (*MCParticle) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{7} }

func (m *MCParticle) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MCParticle) GetParents() []*Reference {
	if m != nil {
		return m.Parents
	}
	return nil
}

func (m *MCParticle) GetChildren() []*Reference {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *MCParticle) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *MCParticle) GetVertex() []float64 {
	if m != nil {
		return m.Vertex
	}
	return nil
}

func (m *MCParticle) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *MCParticle) GetP() []float64 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *MCParticle) GetMass() float64 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *MCParticle) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *MCParticle) GetPEndPoint() []float64 {
	if m != nil {
		return m.PEndPoint
	}
	return nil
}

func (m *MCParticle) GetSpin() []float32 {
	if m != nil {
		return m.Spin
	}
	return nil
}

func (m *MCParticle) GetColorFlow() []int32 {
	if m != nil {
		return m.ColorFlow
	}
	return nil
}

func (m *MCParticle) GetGenStatus() int32 {
	if m != nil {
		return m.GenStatus
	}
	return 0
}

func (m *MCParticle) GetSimStatus() uint32 {
	if m != nil {
		return m.SimStatus
	}
	return 0
}

type MCParticleCollection struct {
	Id      uint32        `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32        `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params       `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*MCParticle `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *MCParticleCollection) Reset()                    { *m = MCParticleCollection{} }
func (m *MCParticleCollection) String() string            { return proto.CompactTextString(m) }
func (*MCParticleCollection) ProtoMessage()               {}
func (*MCParticleCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{8} }

func (m *MCParticleCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MCParticleCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *MCParticleCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *MCParticleCollection) GetEntries() []*MCParticle {
	if m != nil {
		return m.Entries
	}
	return nil
}

type SimTrackerHit struct {
	Id         uint32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0    int32      `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1    int32      `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Pos        []float64  `protobuf:"fixed64,4,rep,packed,name=pos" json:"pos,omitempty"`
	EDep       float32    `protobuf:"fixed32,5,opt,name=EDep,proto3" json:"EDep,omitempty"`
	Time       float32    `protobuf:"fixed32,6,opt,name=time,proto3" json:"time,omitempty"`
	Mc         *Reference `protobuf:"bytes,7,opt,name=mc" json:"mc,omitempty"`
	P          []float32  `protobuf:"fixed32,8,rep,packed,name=p" json:"p,omitempty"`
	PathLength float32    `protobuf:"fixed32,9,opt,name=pathLength,proto3" json:"pathLength,omitempty"`
	Quality    int32      `protobuf:"varint,10,opt,name=quality,proto3" json:"quality,omitempty"`
}

func (m *SimTrackerHit) Reset()                    { *m = SimTrackerHit{} }
func (m *SimTrackerHit) String() string            { return proto.CompactTextString(m) }
func (*SimTrackerHit) ProtoMessage()               {}
func (*SimTrackerHit) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{9} }

func (m *SimTrackerHit) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SimTrackerHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *SimTrackerHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *SimTrackerHit) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *SimTrackerHit) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *SimTrackerHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SimTrackerHit) GetMc() *Reference {
	if m != nil {
		return m.Mc
	}
	return nil
}

func (m *SimTrackerHit) GetP() []float32 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *SimTrackerHit) GetPathLength() float32 {
	if m != nil {
		return m.PathLength
	}
	return 0
}

func (m *SimTrackerHit) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

type SimTrackerHitCollection struct {
	Id      uint32           `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32           `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params          `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*SimTrackerHit `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *SimTrackerHitCollection) Reset()                    { *m = SimTrackerHitCollection{} }
func (m *SimTrackerHitCollection) String() string            { return proto.CompactTextString(m) }
func (*SimTrackerHitCollection) ProtoMessage()               {}
func (*SimTrackerHitCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{10} }

func (m *SimTrackerHitCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SimTrackerHitCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *SimTrackerHitCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *SimTrackerHitCollection) GetEntries() []*SimTrackerHit {
	if m != nil {
		return m.Entries
	}
	return nil
}

type TrackerRawData struct {
	Id      uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0 int32    `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32    `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time    int32    `protobuf:"varint,4,opt,name=time,proto3" json:"time,omitempty"`
	ADCs    []uint32 `protobuf:"varint,5,rep,packed,name=ADCs" json:"ADCs,omitempty"`
}

func (m *TrackerRawData) Reset()                    { *m = TrackerRawData{} }
func (m *TrackerRawData) String() string            { return proto.CompactTextString(m) }
func (*TrackerRawData) ProtoMessage()               {}
func (*TrackerRawData) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{11} }

func (m *TrackerRawData) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerRawData) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerRawData) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerRawData) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerRawData) GetADCs() []uint32 {
	if m != nil {
		return m.ADCs
	}
	return nil
}

type TrackerRawDataCollection struct {
	Id      uint32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32            `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params           `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*TrackerRawData `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackerRawDataCollection) Reset()                    { *m = TrackerRawDataCollection{} }
func (m *TrackerRawDataCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerRawDataCollection) ProtoMessage()               {}
func (*TrackerRawDataCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{12} }

func (m *TrackerRawDataCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerRawDataCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerRawDataCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerRawDataCollection) GetEntries() []*TrackerRawData {
	if m != nil {
		return m.Entries
	}
	return nil
}

type TrackerData struct {
	Id      uint32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0 int32     `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32     `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time    float32   `protobuf:"fixed32,4,opt,name=time,proto3" json:"time,omitempty"`
	Charges []float32 `protobuf:"fixed32,5,rep,packed,name=charges" json:"charges,omitempty"`
}

func (m *TrackerData) Reset()                    { *m = TrackerData{} }
func (m *TrackerData) String() string            { return proto.CompactTextString(m) }
func (*TrackerData) ProtoMessage()               {}
func (*TrackerData) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{13} }

func (m *TrackerData) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerData) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerData) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerData) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerData) GetCharges() []float32 {
	if m != nil {
		return m.Charges
	}
	return nil
}

type TrackerDataCollection struct {
	Id      uint32         `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32         `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params        `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*TrackerData `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackerDataCollection) Reset()                    { *m = TrackerDataCollection{} }
func (m *TrackerDataCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerDataCollection) ProtoMessage()               {}
func (*TrackerDataCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{14} }

func (m *TrackerDataCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerDataCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerDataCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerDataCollection) GetEntries() []*TrackerData {
	if m != nil {
		return m.Entries
	}
	return nil
}

type TrackerHit struct {
	Id      uint32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0 int32        `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32        `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type    int32        `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	Pos     []float64    `protobuf:"fixed64,5,rep,packed,name=pos" json:"pos,omitempty"`
	Cov     []float64    `protobuf:"fixed64,6,rep,packed,name=cov" json:"cov,omitempty"`
	EDep    float32      `protobuf:"fixed32,7,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr float32      `protobuf:"fixed32,8,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time    float32      `protobuf:"fixed32,9,opt,name=time,proto3" json:"time,omitempty"`
	Quality int32        `protobuf:"varint,10,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits []*Reference `protobuf:"bytes,11,rep,name=rawHits" json:"rawHits,omitempty"`
}

func (m *TrackerHit) Reset()                    { *m = TrackerHit{} }
func (m *TrackerHit) String() string            { return proto.CompactTextString(m) }
func (*TrackerHit) ProtoMessage()               {}
func (*TrackerHit) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{15} }

func (m *TrackerHit) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHit) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHit) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHit) GetCov() []float64 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *TrackerHit) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHit) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHit) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHit) GetRawHits() []*Reference {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type TrackerHitCollection struct {
	Id      uint32        `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32        `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params       `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*TrackerHit `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackerHitCollection) Reset()                    { *m = TrackerHitCollection{} }
func (m *TrackerHitCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitCollection) ProtoMessage()               {}
func (*TrackerHitCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{16} }

func (m *TrackerHitCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerHitCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerHitCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerHitCollection) GetEntries() []*TrackerHit {
	if m != nil {
		return m.Entries
	}
	return nil
}

type TrackerPulse struct {
	Id      uint32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0 int32      `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32      `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time    float32    `protobuf:"fixed32,4,opt,name=time,proto3" json:"time,omitempty"`
	Charge  float32    `protobuf:"fixed32,5,opt,name=charge,proto3" json:"charge,omitempty"`
	Cov     []float32  `protobuf:"fixed32,6,rep,packed,name=cov" json:"cov,omitempty"`
	Quality int32      `protobuf:"varint,7,opt,name=quality,proto3" json:"quality,omitempty"`
	TPC     *Reference `protobuf:"bytes,8,opt,name=TPC" json:"TPC,omitempty"`
}

func (m *TrackerPulse) Reset()                    { *m = TrackerPulse{} }
func (m *TrackerPulse) String() string            { return proto.CompactTextString(m) }
func (*TrackerPulse) ProtoMessage()               {}
func (*TrackerPulse) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{17} }

func (m *TrackerPulse) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerPulse) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerPulse) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerPulse) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerPulse) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *TrackerPulse) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *TrackerPulse) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerPulse) GetTPC() *Reference {
	if m != nil {
		return m.TPC
	}
	return nil
}

type TrackerPulseCollection struct {
	Id      uint32          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32          `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params         `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*TrackerPulse `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackerPulseCollection) Reset()                    { *m = TrackerPulseCollection{} }
func (m *TrackerPulseCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerPulseCollection) ProtoMessage()               {}
func (*TrackerPulseCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{18} }

func (m *TrackerPulseCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerPulseCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerPulseCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerPulseCollection) GetEntries() []*TrackerPulse {
	if m != nil {
		return m.Entries
	}
	return nil
}

type TrackerHitPlane struct {
	Id      uint32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0 int32        `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32        `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type    int32        `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	Pos     []float64    `protobuf:"fixed64,5,rep,packed,name=pos" json:"pos,omitempty"`
	U       []float32    `protobuf:"fixed32,6,rep,packed,name=U" json:"U,omitempty"`
	V       []float32    `protobuf:"fixed32,7,rep,packed,name=V" json:"V,omitempty"`
	DU      float32      `protobuf:"fixed32,8,opt,name=dU,proto3" json:"dU,omitempty"`
	DV      float32      `protobuf:"fixed32,9,opt,name=dV,proto3" json:"dV,omitempty"`
	EDep    float32      `protobuf:"fixed32,10,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr float32      `protobuf:"fixed32,11,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time    float32      `protobuf:"fixed32,12,opt,name=time,proto3" json:"time,omitempty"`
	Quality int32        `protobuf:"varint,13,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits []*Reference `protobuf:"bytes,14,rep,name=rawHits" json:"rawHits,omitempty"`
}

func (m *TrackerHitPlane) Reset()                    { *m = TrackerHitPlane{} }
func (m *TrackerHitPlane) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitPlane) ProtoMessage()               {}
func (*TrackerHitPlane) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{19} }

func (m *TrackerHitPlane) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerHitPlane) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHitPlane) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHitPlane) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHitPlane) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHitPlane) GetU() []float32 {
	if m != nil {
		return m.U
	}
	return nil
}

func (m *TrackerHitPlane) GetV() []float32 {
	if m != nil {
		return m.V
	}
	return nil
}

func (m *TrackerHitPlane) GetDU() float32 {
	if m != nil {
		return m.DU
	}
	return 0
}

func (m *TrackerHitPlane) GetDV() float32 {
	if m != nil {
		return m.DV
	}
	return 0
}

func (m *TrackerHitPlane) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHitPlane) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHitPlane) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHitPlane) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHitPlane) GetRawHits() []*Reference {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type TrackerHitPlaneCollection struct {
	Id      uint32             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32             `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params            `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*TrackerHitPlane `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackerHitPlaneCollection) Reset()                    { *m = TrackerHitPlaneCollection{} }
func (m *TrackerHitPlaneCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitPlaneCollection) ProtoMessage()               {}
func (*TrackerHitPlaneCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{20} }

func (m *TrackerHitPlaneCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerHitPlaneCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerHitPlaneCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerHitPlaneCollection) GetEntries() []*TrackerHitPlane {
	if m != nil {
		return m.Entries
	}
	return nil
}

type TrackerHitZCylinder struct {
	Id      uint32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0 int32        `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1 int32        `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type    int32        `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	Pos     []float64    `protobuf:"fixed64,5,rep,packed,name=pos" json:"pos,omitempty"`
	Center  []float32    `protobuf:"fixed32,6,rep,packed,name=center" json:"center,omitempty"`
	DRPhi   float32      `protobuf:"fixed32,7,opt,name=dRPhi,proto3" json:"dRPhi,omitempty"`
	DZ      float32      `protobuf:"fixed32,8,opt,name=dZ,proto3" json:"dZ,omitempty"`
	EDep    float32      `protobuf:"fixed32,9,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr float32      `protobuf:"fixed32,10,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time    float32      `protobuf:"fixed32,11,opt,name=time,proto3" json:"time,omitempty"`
	Quality int32        `protobuf:"varint,12,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits []*Reference `protobuf:"bytes,13,rep,name=rawHits" json:"rawHits,omitempty"`
}

func (m *TrackerHitZCylinder) Reset()                    { *m = TrackerHitZCylinder{} }
func (m *TrackerHitZCylinder) String() string            { return proto.CompactTextString(m) }
func (*TrackerHitZCylinder) ProtoMessage()               {}
func (*TrackerHitZCylinder) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{21} }

func (m *TrackerHitZCylinder) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerHitZCylinder) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHitZCylinder) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHitZCylinder) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHitZCylinder) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHitZCylinder) GetCenter() []float32 {
	if m != nil {
		return m.Center
	}
	return nil
}

func (m *TrackerHitZCylinder) GetDRPhi() float32 {
	if m != nil {
		return m.DRPhi
	}
	return 0
}

func (m *TrackerHitZCylinder) GetDZ() float32 {
	if m != nil {
		return m.DZ
	}
	return 0
}

func (m *TrackerHitZCylinder) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHitZCylinder) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHitZCylinder) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHitZCylinder) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHitZCylinder) GetRawHits() []*Reference {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type TrackerHitZCylinderCollection struct {
	Id      uint32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32                 `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params                `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*TrackerHitZCylinder `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackerHitZCylinderCollection) Reset()         { *m = TrackerHitZCylinderCollection{} }
func (m *TrackerHitZCylinderCollection) String() string { return proto.CompactTextString(m) }
func (*TrackerHitZCylinderCollection) ProtoMessage()    {}
func (*TrackerHitZCylinderCollection) Descriptor() ([]byte, []int) {
	return fileDescriptorEicio, []int{22}
}

func (m *TrackerHitZCylinderCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackerHitZCylinderCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackerHitZCylinderCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackerHitZCylinderCollection) GetEntries() []*TrackerHitZCylinder {
	if m != nil {
		return m.Entries
	}
	return nil
}

type Track struct {
	Id         uint32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type       int32               `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Chi2       float32             `protobuf:"fixed32,3,opt,name=chi2,proto3" json:"chi2,omitempty"`
	NDF        int32               `protobuf:"varint,4,opt,name=NDF,proto3" json:"NDF,omitempty"`
	DEdx       float32             `protobuf:"fixed32,5,opt,name=dEdx,proto3" json:"dEdx,omitempty"`
	DEdxErr    float32             `protobuf:"fixed32,6,opt,name=dEdxErr,proto3" json:"dEdxErr,omitempty"`
	Radius     float32             `protobuf:"fixed32,7,opt,name=radius,proto3" json:"radius,omitempty"`
	SubDetHits []int32             `protobuf:"varint,8,rep,packed,name=subDetHits" json:"subDetHits,omitempty"`
	States     []*Track_TrackState `protobuf:"bytes,9,rep,name=states" json:"states,omitempty"`
	Hits       []*Reference        `protobuf:"bytes,10,rep,name=hits" json:"hits,omitempty"`
	Tracks     []*Reference        `protobuf:"bytes,11,rep,name=tracks" json:"tracks,omitempty"`
}

func (m *Track) Reset()                    { *m = Track{} }
func (m *Track) String() string            { return proto.CompactTextString(m) }
func (*Track) ProtoMessage()               {}
func (*Track) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{23} }

func (m *Track) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Track) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Track) GetChi2() float32 {
	if m != nil {
		return m.Chi2
	}
	return 0
}

func (m *Track) GetNDF() int32 {
	if m != nil {
		return m.NDF
	}
	return 0
}

func (m *Track) GetDEdx() float32 {
	if m != nil {
		return m.DEdx
	}
	return 0
}

func (m *Track) GetDEdxErr() float32 {
	if m != nil {
		return m.DEdxErr
	}
	return 0
}

func (m *Track) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *Track) GetSubDetHits() []int32 {
	if m != nil {
		return m.SubDetHits
	}
	return nil
}

func (m *Track) GetStates() []*Track_TrackState {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *Track) GetHits() []*Reference {
	if m != nil {
		return m.Hits
	}
	return nil
}

func (m *Track) GetTracks() []*Reference {
	if m != nil {
		return m.Tracks
	}
	return nil
}

type Track_TrackState struct {
	Loc   int32     `protobuf:"varint,1,opt,name=loc,proto3" json:"loc,omitempty"`
	D0    float32   `protobuf:"fixed32,2,opt,name=d0,proto3" json:"d0,omitempty"`
	Phi   float32   `protobuf:"fixed32,3,opt,name=phi,proto3" json:"phi,omitempty"`
	Omega float32   `protobuf:"fixed32,4,opt,name=omega,proto3" json:"omega,omitempty"`
	Z0    float32   `protobuf:"fixed32,5,opt,name=z0,proto3" json:"z0,omitempty"`
	TanL  float32   `protobuf:"fixed32,6,opt,name=tanL,proto3" json:"tanL,omitempty"`
	Cov   []float32 `protobuf:"fixed32,7,rep,packed,name=cov" json:"cov,omitempty"`
	Ref   []float32 `protobuf:"fixed32,8,rep,packed,name=ref" json:"ref,omitempty"`
}

func (m *Track_TrackState) Reset()                    { *m = Track_TrackState{} }
func (m *Track_TrackState) String() string            { return proto.CompactTextString(m) }
func (*Track_TrackState) ProtoMessage()               {}
func (*Track_TrackState) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{23, 0} }

func (m *Track_TrackState) GetLoc() int32 {
	if m != nil {
		return m.Loc
	}
	return 0
}

func (m *Track_TrackState) GetD0() float32 {
	if m != nil {
		return m.D0
	}
	return 0
}

func (m *Track_TrackState) GetPhi() float32 {
	if m != nil {
		return m.Phi
	}
	return 0
}

func (m *Track_TrackState) GetOmega() float32 {
	if m != nil {
		return m.Omega
	}
	return 0
}

func (m *Track_TrackState) GetZ0() float32 {
	if m != nil {
		return m.Z0
	}
	return 0
}

func (m *Track_TrackState) GetTanL() float32 {
	if m != nil {
		return m.TanL
	}
	return 0
}

func (m *Track_TrackState) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *Track_TrackState) GetRef() []float32 {
	if m != nil {
		return m.Ref
	}
	return nil
}

type TrackCollection struct {
	Id      uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32   `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params  `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*Track `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackCollection) Reset()                    { *m = TrackCollection{} }
func (m *TrackCollection) String() string            { return proto.CompactTextString(m) }
func (*TrackCollection) ProtoMessage()               {}
func (*TrackCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{24} }

func (m *TrackCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TrackCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *TrackCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TrackCollection) GetEntries() []*Track {
	if m != nil {
		return m.Entries
	}
	return nil
}

type SimCalorimeterHit struct {
	Id            uint32                       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Params        *Params                      `protobuf:"bytes,2,opt,name=params" json:"params,omitempty"`
	CellID0       int32                        `protobuf:"varint,3,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1       int32                        `protobuf:"varint,4,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Energy        float32                      `protobuf:"fixed32,5,opt,name=energy,proto3" json:"energy,omitempty"`
	Pos           []float32                    `protobuf:"fixed32,6,rep,packed,name=pos" json:"pos,omitempty"`
	Contributions []*SimCalorimeterHit_Contrib `protobuf:"bytes,7,rep,name=contributions" json:"contributions,omitempty"`
}

func (m *SimCalorimeterHit) Reset()                    { *m = SimCalorimeterHit{} }
func (m *SimCalorimeterHit) String() string            { return proto.CompactTextString(m) }
func (*SimCalorimeterHit) ProtoMessage()               {}
func (*SimCalorimeterHit) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{25} }

func (m *SimCalorimeterHit) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SimCalorimeterHit) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *SimCalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *SimCalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *SimCalorimeterHit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *SimCalorimeterHit) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *SimCalorimeterHit) GetContributions() []*SimCalorimeterHit_Contrib {
	if m != nil {
		return m.Contributions
	}
	return nil
}

type SimCalorimeterHit_Contrib struct {
	MCParticle *Reference `protobuf:"bytes,1,opt,name=MCParticle" json:"MCParticle,omitempty"`
	Energy     float32    `protobuf:"fixed32,2,opt,name=energy,proto3" json:"energy,omitempty"`
	Time       float32    `protobuf:"fixed32,3,opt,name=time,proto3" json:"time,omitempty"`
	PDG        int32      `protobuf:"varint,4,opt,name=PDG,proto3" json:"PDG,omitempty"`
	StepPos    []float32  `protobuf:"fixed32,5,rep,packed,name=stepPos" json:"stepPos,omitempty"`
}

func (m *SimCalorimeterHit_Contrib) Reset()         { *m = SimCalorimeterHit_Contrib{} }
func (m *SimCalorimeterHit_Contrib) String() string { return proto.CompactTextString(m) }
func (*SimCalorimeterHit_Contrib) ProtoMessage()    {}
func (*SimCalorimeterHit_Contrib) Descriptor() ([]byte, []int) {
	return fileDescriptorEicio, []int{25, 0}
}

func (m *SimCalorimeterHit_Contrib) GetMCParticle() *Reference {
	if m != nil {
		return m.MCParticle
	}
	return nil
}

func (m *SimCalorimeterHit_Contrib) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetStepPos() []float32 {
	if m != nil {
		return m.StepPos
	}
	return nil
}

type SimCalorimeterHitCollection struct {
	Id      uint32               `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32               `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params              `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*SimCalorimeterHit `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *SimCalorimeterHitCollection) Reset()         { *m = SimCalorimeterHitCollection{} }
func (m *SimCalorimeterHitCollection) String() string { return proto.CompactTextString(m) }
func (*SimCalorimeterHitCollection) ProtoMessage()    {}
func (*SimCalorimeterHitCollection) Descriptor() ([]byte, []int) {
	return fileDescriptorEicio, []int{26}
}

func (m *SimCalorimeterHitCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SimCalorimeterHitCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *SimCalorimeterHitCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *SimCalorimeterHitCollection) GetEntries() []*SimCalorimeterHit {
	if m != nil {
		return m.Entries
	}
	return nil
}

type RawCalorimeterHit struct {
	Id        uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0   int32  `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1   int32  `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Amplitude int32  `protobuf:"varint,4,opt,name=amplitude,proto3" json:"amplitude,omitempty"`
	TimeStamp int32  `protobuf:"varint,5,opt,name=timeStamp,proto3" json:"timeStamp,omitempty"`
}

func (m *RawCalorimeterHit) Reset()                    { *m = RawCalorimeterHit{} }
func (m *RawCalorimeterHit) String() string            { return proto.CompactTextString(m) }
func (*RawCalorimeterHit) ProtoMessage()               {}
func (*RawCalorimeterHit) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{27} }

func (m *RawCalorimeterHit) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RawCalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *RawCalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *RawCalorimeterHit) GetAmplitude() int32 {
	if m != nil {
		return m.Amplitude
	}
	return 0
}

func (m *RawCalorimeterHit) GetTimeStamp() int32 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

type RawCalorimeterHitCollection struct {
	Id      uint32               `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32               `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params              `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*RawCalorimeterHit `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *RawCalorimeterHitCollection) Reset()         { *m = RawCalorimeterHitCollection{} }
func (m *RawCalorimeterHitCollection) String() string { return proto.CompactTextString(m) }
func (*RawCalorimeterHitCollection) ProtoMessage()    {}
func (*RawCalorimeterHitCollection) Descriptor() ([]byte, []int) {
	return fileDescriptorEicio, []int{28}
}

func (m *RawCalorimeterHitCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RawCalorimeterHitCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RawCalorimeterHitCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *RawCalorimeterHitCollection) GetEntries() []*RawCalorimeterHit {
	if m != nil {
		return m.Entries
	}
	return nil
}

type CalorimeterHit struct {
	Id        uint32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CellID0   int32      `protobuf:"varint,2,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1   int32      `protobuf:"varint,3,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Energy    float32    `protobuf:"fixed32,4,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyErr float32    `protobuf:"fixed32,5,opt,name=energyErr,proto3" json:"energyErr,omitempty"`
	Time      float32    `protobuf:"fixed32,6,opt,name=time,proto3" json:"time,omitempty"`
	Pos       []float32  `protobuf:"fixed32,7,rep,packed,name=pos" json:"pos,omitempty"`
	Type      int32      `protobuf:"varint,8,opt,name=type,proto3" json:"type,omitempty"`
	Raw       *Reference `protobuf:"bytes,9,opt,name=raw" json:"raw,omitempty"`
}

func (m *CalorimeterHit) Reset()                    { *m = CalorimeterHit{} }
func (m *CalorimeterHit) String() string            { return proto.CompactTextString(m) }
func (*CalorimeterHit) ProtoMessage()               {}
func (*CalorimeterHit) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{29} }

func (m *CalorimeterHit) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *CalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *CalorimeterHit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *CalorimeterHit) GetEnergyErr() float32 {
	if m != nil {
		return m.EnergyErr
	}
	return 0
}

func (m *CalorimeterHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *CalorimeterHit) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *CalorimeterHit) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CalorimeterHit) GetRaw() *Reference {
	if m != nil {
		return m.Raw
	}
	return nil
}

type CalorimeterHitCollection struct {
	Id      uint32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32            `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params           `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*CalorimeterHit `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *CalorimeterHitCollection) Reset()                    { *m = CalorimeterHitCollection{} }
func (m *CalorimeterHitCollection) String() string            { return proto.CompactTextString(m) }
func (*CalorimeterHitCollection) ProtoMessage()               {}
func (*CalorimeterHitCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{30} }

func (m *CalorimeterHitCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CalorimeterHitCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *CalorimeterHitCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *CalorimeterHitCollection) GetEntries() []*CalorimeterHit {
	if m != nil {
		return m.Entries
	}
	return nil
}

type Cluster struct {
	Id         uint32        `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type       int32         `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Energy     float32       `protobuf:"fixed32,3,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyErr  float32       `protobuf:"fixed32,4,opt,name=energyErr,proto3" json:"energyErr,omitempty"`
	Pos        []float32     `protobuf:"fixed32,5,rep,packed,name=pos" json:"pos,omitempty"`
	PosErr     []float32     `protobuf:"fixed32,6,rep,packed,name=posErr" json:"posErr,omitempty"`
	Theta      float32       `protobuf:"fixed32,7,opt,name=theta,proto3" json:"theta,omitempty"`
	Phi        float32       `protobuf:"fixed32,8,opt,name=phi,proto3" json:"phi,omitempty"`
	DirErr     []float32     `protobuf:"fixed32,9,rep,packed,name=dirErr" json:"dirErr,omitempty"`
	Shape      []float32     `protobuf:"fixed32,10,rep,packed,name=shape" json:"shape,omitempty"`
	PIDs       []*ParticleID `protobuf:"bytes,11,rep,name=PIDs" json:"PIDs,omitempty"`
	Clusters   []*Reference  `protobuf:"bytes,12,rep,name=clusters" json:"clusters,omitempty"`
	Hits       []*Reference  `protobuf:"bytes,13,rep,name=hits" json:"hits,omitempty"`
	Weights    []float32     `protobuf:"fixed32,14,rep,packed,name=weights" json:"weights,omitempty"`
	SubDetEnes []float32     `protobuf:"fixed32,15,rep,packed,name=subDetEnes" json:"subDetEnes,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{31} }

func (m *Cluster) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Cluster) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Cluster) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *Cluster) GetEnergyErr() float32 {
	if m != nil {
		return m.EnergyErr
	}
	return 0
}

func (m *Cluster) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Cluster) GetPosErr() []float32 {
	if m != nil {
		return m.PosErr
	}
	return nil
}

func (m *Cluster) GetTheta() float32 {
	if m != nil {
		return m.Theta
	}
	return 0
}

func (m *Cluster) GetPhi() float32 {
	if m != nil {
		return m.Phi
	}
	return 0
}

func (m *Cluster) GetDirErr() []float32 {
	if m != nil {
		return m.DirErr
	}
	return nil
}

func (m *Cluster) GetShape() []float32 {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *Cluster) GetPIDs() []*ParticleID {
	if m != nil {
		return m.PIDs
	}
	return nil
}

func (m *Cluster) GetClusters() []*Reference {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *Cluster) GetHits() []*Reference {
	if m != nil {
		return m.Hits
	}
	return nil
}

func (m *Cluster) GetWeights() []float32 {
	if m != nil {
		return m.Weights
	}
	return nil
}

func (m *Cluster) GetSubDetEnes() []float32 {
	if m != nil {
		return m.SubDetEnes
	}
	return nil
}

type ClusterCollection struct {
	Id      uint32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32     `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params    `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*Cluster `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *ClusterCollection) Reset()                    { *m = ClusterCollection{} }
func (m *ClusterCollection) String() string            { return proto.CompactTextString(m) }
func (*ClusterCollection) ProtoMessage()               {}
func (*ClusterCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{32} }

func (m *ClusterCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ClusterCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ClusterCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *ClusterCollection) GetEntries() []*Cluster {
	if m != nil {
		return m.Entries
	}
	return nil
}

type RecParticle struct {
	Id            uint32        `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type          int32         `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	P             []float32     `protobuf:"fixed32,3,rep,packed,name=p" json:"p,omitempty"`
	Energy        float32       `protobuf:"fixed32,4,opt,name=energy,proto3" json:"energy,omitempty"`
	Cov           []float32     `protobuf:"fixed32,5,rep,packed,name=cov" json:"cov,omitempty"`
	Mass          float32       `protobuf:"fixed32,6,opt,name=mass,proto3" json:"mass,omitempty"`
	Charge        float32       `protobuf:"fixed32,7,opt,name=charge,proto3" json:"charge,omitempty"`
	Ref           []float32     `protobuf:"fixed32,8,rep,packed,name=ref" json:"ref,omitempty"`
	PIDs          []*ParticleID `protobuf:"bytes,9,rep,name=PIDs" json:"PIDs,omitempty"`
	PIDUsed       int32         `protobuf:"varint,10,opt,name=PIDUsed,proto3" json:"PIDUsed,omitempty"`
	GoodnessOfPID float32       `protobuf:"fixed32,11,opt,name=goodnessOfPID,proto3" json:"goodnessOfPID,omitempty"`
	Recs          []*Reference  `protobuf:"bytes,12,rep,name=recs" json:"recs,omitempty"`
	Tracks        []*Reference  `protobuf:"bytes,13,rep,name=tracks" json:"tracks,omitempty"`
	Clusters      []*Reference  `protobuf:"bytes,14,rep,name=clusters" json:"clusters,omitempty"`
	StartVtx      *Reference    `protobuf:"bytes,15,opt,name=startVtx" json:"startVtx,omitempty"`
}

func (m *RecParticle) Reset()                    { *m = RecParticle{} }
func (m *RecParticle) String() string            { return proto.CompactTextString(m) }
func (*RecParticle) ProtoMessage()               {}
func (*RecParticle) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{33} }

func (m *RecParticle) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RecParticle) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RecParticle) GetP() []float32 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *RecParticle) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *RecParticle) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *RecParticle) GetMass() float32 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *RecParticle) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *RecParticle) GetRef() []float32 {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *RecParticle) GetPIDs() []*ParticleID {
	if m != nil {
		return m.PIDs
	}
	return nil
}

func (m *RecParticle) GetPIDUsed() int32 {
	if m != nil {
		return m.PIDUsed
	}
	return 0
}

func (m *RecParticle) GetGoodnessOfPID() float32 {
	if m != nil {
		return m.GoodnessOfPID
	}
	return 0
}

func (m *RecParticle) GetRecs() []*Reference {
	if m != nil {
		return m.Recs
	}
	return nil
}

func (m *RecParticle) GetTracks() []*Reference {
	if m != nil {
		return m.Tracks
	}
	return nil
}

func (m *RecParticle) GetClusters() []*Reference {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *RecParticle) GetStartVtx() *Reference {
	if m != nil {
		return m.StartVtx
	}
	return nil
}

type RecParticleCollection struct {
	Id      uint32         `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32         `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params        `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*RecParticle `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *RecParticleCollection) Reset()                    { *m = RecParticleCollection{} }
func (m *RecParticleCollection) String() string            { return proto.CompactTextString(m) }
func (*RecParticleCollection) ProtoMessage()               {}
func (*RecParticleCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{34} }

func (m *RecParticleCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RecParticleCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RecParticleCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *RecParticleCollection) GetEntries() []*RecParticle {
	if m != nil {
		return m.Entries
	}
	return nil
}

type Vertex struct {
	Id      uint32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Primary int32      `protobuf:"varint,2,opt,name=primary,proto3" json:"primary,omitempty"`
	AlgType int32      `protobuf:"varint,3,opt,name=algType,proto3" json:"algType,omitempty"`
	Chi2    float32    `protobuf:"fixed32,4,opt,name=chi2,proto3" json:"chi2,omitempty"`
	Prob    float32    `protobuf:"fixed32,5,opt,name=prob,proto3" json:"prob,omitempty"`
	Pos     []float32  `protobuf:"fixed32,6,rep,packed,name=pos" json:"pos,omitempty"`
	Cov     []float32  `protobuf:"fixed32,7,rep,packed,name=cov" json:"cov,omitempty"`
	Params  []float32  `protobuf:"fixed32,8,rep,packed,name=params" json:"params,omitempty"`
	RecPart *Reference `protobuf:"bytes,9,opt,name=recPart" json:"recPart,omitempty"`
}

func (m *Vertex) Reset()                    { *m = Vertex{} }
func (m *Vertex) String() string            { return proto.CompactTextString(m) }
func (*Vertex) ProtoMessage()               {}
func (*Vertex) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{35} }

func (m *Vertex) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Vertex) GetPrimary() int32 {
	if m != nil {
		return m.Primary
	}
	return 0
}

func (m *Vertex) GetAlgType() int32 {
	if m != nil {
		return m.AlgType
	}
	return 0
}

func (m *Vertex) GetChi2() float32 {
	if m != nil {
		return m.Chi2
	}
	return 0
}

func (m *Vertex) GetProb() float32 {
	if m != nil {
		return m.Prob
	}
	return 0
}

func (m *Vertex) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Vertex) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *Vertex) GetParams() []float32 {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Vertex) GetRecPart() *Reference {
	if m != nil {
		return m.RecPart
	}
	return nil
}

type VertexCollection struct {
	Id      uint32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32    `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params   `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*Vertex `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *VertexCollection) Reset()                    { *m = VertexCollection{} }
func (m *VertexCollection) String() string            { return proto.CompactTextString(m) }
func (*VertexCollection) ProtoMessage()               {}
func (*VertexCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{36} }

func (m *VertexCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *VertexCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *VertexCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *VertexCollection) GetEntries() []*Vertex {
	if m != nil {
		return m.Entries
	}
	return nil
}

type Relation struct {
	Id     uint32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	From   *Reference `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	To     *Reference `protobuf:"bytes,3,opt,name=to" json:"to,omitempty"`
	Weight float32    `protobuf:"fixed32,4,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *Relation) Reset()                    { *m = Relation{} }
func (m *Relation) String() string            { return proto.CompactTextString(m) }
func (*Relation) ProtoMessage()               {}
func (*Relation) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{37} }

func (m *Relation) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Relation) GetFrom() *Reference {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Relation) GetTo() *Reference {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *Relation) GetWeight() float32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

type RelationCollection struct {
	Id      uint32      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Flags   uint32      `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Params  *Params     `protobuf:"bytes,3,opt,name=params" json:"params,omitempty"`
	Entries []*Relation `protobuf:"bytes,4,rep,name=entries" json:"entries,omitempty"`
}

func (m *RelationCollection) Reset()                    { *m = RelationCollection{} }
func (m *RelationCollection) String() string            { return proto.CompactTextString(m) }
func (*RelationCollection) ProtoMessage()               {}
func (*RelationCollection) Descriptor() ([]byte, []int) { return fileDescriptorEicio, []int{38} }

func (m *RelationCollection) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RelationCollection) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RelationCollection) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *RelationCollection) GetEntries() []*Relation {
	if m != nil {
		return m.Entries
	}
	return nil
}

func init() {
	proto.RegisterType((*EventHeader)(nil), "eicio.model.EventHeader")
	proto.RegisterType((*EventHeader_CollectionHeader)(nil), "eicio.model.EventHeader.CollectionHeader")
	proto.RegisterType((*IntParams)(nil), "eicio.model.IntParams")
	proto.RegisterType((*FloatParams)(nil), "eicio.model.FloatParams")
	proto.RegisterType((*StringParams)(nil), "eicio.model.StringParams")
	proto.RegisterType((*Params)(nil), "eicio.model.Params")
	proto.RegisterType((*Reference)(nil), "eicio.model.Reference")
	proto.RegisterType((*ParticleID)(nil), "eicio.model.ParticleID")
	proto.RegisterType((*MCParticle)(nil), "eicio.model.MCParticle")
	proto.RegisterType((*MCParticleCollection)(nil), "eicio.model.MCParticleCollection")
	proto.RegisterType((*SimTrackerHit)(nil), "eicio.model.SimTrackerHit")
	proto.RegisterType((*SimTrackerHitCollection)(nil), "eicio.model.SimTrackerHitCollection")
	proto.RegisterType((*TrackerRawData)(nil), "eicio.model.TrackerRawData")
	proto.RegisterType((*TrackerRawDataCollection)(nil), "eicio.model.TrackerRawDataCollection")
	proto.RegisterType((*TrackerData)(nil), "eicio.model.TrackerData")
	proto.RegisterType((*TrackerDataCollection)(nil), "eicio.model.TrackerDataCollection")
	proto.RegisterType((*TrackerHit)(nil), "eicio.model.TrackerHit")
	proto.RegisterType((*TrackerHitCollection)(nil), "eicio.model.TrackerHitCollection")
	proto.RegisterType((*TrackerPulse)(nil), "eicio.model.TrackerPulse")
	proto.RegisterType((*TrackerPulseCollection)(nil), "eicio.model.TrackerPulseCollection")
	proto.RegisterType((*TrackerHitPlane)(nil), "eicio.model.TrackerHitPlane")
	proto.RegisterType((*TrackerHitPlaneCollection)(nil), "eicio.model.TrackerHitPlaneCollection")
	proto.RegisterType((*TrackerHitZCylinder)(nil), "eicio.model.TrackerHitZCylinder")
	proto.RegisterType((*TrackerHitZCylinderCollection)(nil), "eicio.model.TrackerHitZCylinderCollection")
	proto.RegisterType((*Track)(nil), "eicio.model.Track")
	proto.RegisterType((*Track_TrackState)(nil), "eicio.model.Track.TrackState")
	proto.RegisterType((*TrackCollection)(nil), "eicio.model.TrackCollection")
	proto.RegisterType((*SimCalorimeterHit)(nil), "eicio.model.SimCalorimeterHit")
	proto.RegisterType((*SimCalorimeterHit_Contrib)(nil), "eicio.model.SimCalorimeterHit.Contrib")
	proto.RegisterType((*SimCalorimeterHitCollection)(nil), "eicio.model.SimCalorimeterHitCollection")
	proto.RegisterType((*RawCalorimeterHit)(nil), "eicio.model.RawCalorimeterHit")
	proto.RegisterType((*RawCalorimeterHitCollection)(nil), "eicio.model.RawCalorimeterHitCollection")
	proto.RegisterType((*CalorimeterHit)(nil), "eicio.model.CalorimeterHit")
	proto.RegisterType((*CalorimeterHitCollection)(nil), "eicio.model.CalorimeterHitCollection")
	proto.RegisterType((*Cluster)(nil), "eicio.model.Cluster")
	proto.RegisterType((*ClusterCollection)(nil), "eicio.model.ClusterCollection")
	proto.RegisterType((*RecParticle)(nil), "eicio.model.RecParticle")
	proto.RegisterType((*RecParticleCollection)(nil), "eicio.model.RecParticleCollection")
	proto.RegisterType((*Vertex)(nil), "eicio.model.Vertex")
	proto.RegisterType((*VertexCollection)(nil), "eicio.model.VertexCollection")
	proto.RegisterType((*Relation)(nil), "eicio.model.Relation")
	proto.RegisterType((*RelationCollection)(nil), "eicio.model.RelationCollection")
}
func (m *EventHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Version))
	}
	if m.RunNumber != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.RunNumber))
	}
	if m.EventNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.EventNumber))
	}
	if m.TimeStamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.TimeStamp))
	}
	if len(m.Detector) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Detector)))
		i += copy(dAtA[i:], m.Detector)
	}
	if m.Params != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n1, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.PayloadCollections) > 0 {
		for _, msg := range m.PayloadCollections {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NUniqueIDs != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.NUniqueIDs))
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	return i, nil
}

func (m *EventHeader_CollectionHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventHeader_CollectionHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.PayloadSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.PayloadSize))
	}
	return i, nil
}

func (m *IntParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Array) > 0 {
		dAtA3 := make([]byte, len(m.Array)*10)
		var j2 int
		for _, num1 := range m.Array {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintEicio(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	return i, nil
}

func (m *FloatParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Array) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Array)*4))
		for _, num := range m.Array {
			f4 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f4)
			i++
			dAtA[i] = uint8(f4 >> 8)
			i++
			dAtA[i] = uint8(f4 >> 16)
			i++
			dAtA[i] = uint8(f4 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *StringParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Array) > 0 {
		for _, s := range m.Array {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ints) > 0 {
		for k, _ := range m.Ints {
			dAtA[i] = 0xa
			i++
			v := m.Ints[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovEicio(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovEicio(uint64(len(k))) + msgSize
			i = encodeVarintEicio(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintEicio(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintEicio(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if len(m.Floats) > 0 {
		for k, _ := range m.Floats {
			dAtA[i] = 0x12
			i++
			v := m.Floats[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovEicio(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovEicio(uint64(len(k))) + msgSize
			i = encodeVarintEicio(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintEicio(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintEicio(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	if len(m.Strings) > 0 {
		for k, _ := range m.Strings {
			dAtA[i] = 0x1a
			i++
			v := m.Strings[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovEicio(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovEicio(uint64(len(k))) + msgSize
			i = encodeVarintEicio(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintEicio(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintEicio(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	return i, nil
}

func (m *Reference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CollID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CollID))
	}
	if m.EntryID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.EntryID))
	}
	return i, nil
}

func (m *ParticleID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParticleID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Likelihood != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Likelihood))))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if m.PDG != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.PDG))
	}
	if m.AlgType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.AlgType))
	}
	if len(m.Params) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Params)*4))
		for _, num := range m.Params {
			f8 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f8)
			i++
			dAtA[i] = uint8(f8 >> 8)
			i++
			dAtA[i] = uint8(f8 >> 16)
			i++
			dAtA[i] = uint8(f8 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *MCParticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MCParticle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if len(m.Parents) > 0 {
		for _, msg := range m.Parents {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PDG != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.PDG))
	}
	if len(m.Vertex) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Vertex)*8))
		for _, num := range m.Vertex {
			f9 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f9)
			i++
			dAtA[i] = uint8(f9 >> 8)
			i++
			dAtA[i] = uint8(f9 >> 16)
			i++
			dAtA[i] = uint8(f9 >> 24)
			i++
			dAtA[i] = uint8(f9 >> 32)
			i++
			dAtA[i] = uint8(f9 >> 40)
			i++
			dAtA[i] = uint8(f9 >> 48)
			i++
			dAtA[i] = uint8(f9 >> 56)
			i++
		}
	}
	if m.Time != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.P)*8))
		for _, num := range m.P {
			f10 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f10)
			i++
			dAtA[i] = uint8(f10 >> 8)
			i++
			dAtA[i] = uint8(f10 >> 16)
			i++
			dAtA[i] = uint8(f10 >> 24)
			i++
			dAtA[i] = uint8(f10 >> 32)
			i++
			dAtA[i] = uint8(f10 >> 40)
			i++
			dAtA[i] = uint8(f10 >> 48)
			i++
			dAtA[i] = uint8(f10 >> 56)
			i++
		}
	}
	if m.Mass != 0 {
		dAtA[i] = 0x41
		i++
		i = encodeFixed64Eicio(dAtA, i, uint64(math.Float64bits(float64(m.Mass))))
	}
	if m.Charge != 0 {
		dAtA[i] = 0x4d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Charge))))
	}
	if len(m.PEndPoint) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.PEndPoint)*8))
		for _, num := range m.PEndPoint {
			f11 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f11)
			i++
			dAtA[i] = uint8(f11 >> 8)
			i++
			dAtA[i] = uint8(f11 >> 16)
			i++
			dAtA[i] = uint8(f11 >> 24)
			i++
			dAtA[i] = uint8(f11 >> 32)
			i++
			dAtA[i] = uint8(f11 >> 40)
			i++
			dAtA[i] = uint8(f11 >> 48)
			i++
			dAtA[i] = uint8(f11 >> 56)
			i++
		}
	}
	if len(m.Spin) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Spin)*4))
		for _, num := range m.Spin {
			f12 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f12)
			i++
			dAtA[i] = uint8(f12 >> 8)
			i++
			dAtA[i] = uint8(f12 >> 16)
			i++
			dAtA[i] = uint8(f12 >> 24)
			i++
		}
	}
	if len(m.ColorFlow) > 0 {
		dAtA14 := make([]byte, len(m.ColorFlow)*10)
		var j13 int
		for _, num1 := range m.ColorFlow {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintEicio(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if m.GenStatus != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.GenStatus))
	}
	if m.SimStatus != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.SimStatus))
	}
	return i, nil
}

func (m *MCParticleCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MCParticleCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n15, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SimTrackerHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimTrackerHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f16 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f16)
			i++
			dAtA[i] = uint8(f16 >> 8)
			i++
			dAtA[i] = uint8(f16 >> 16)
			i++
			dAtA[i] = uint8(f16 >> 24)
			i++
			dAtA[i] = uint8(f16 >> 32)
			i++
			dAtA[i] = uint8(f16 >> 40)
			i++
			dAtA[i] = uint8(f16 >> 48)
			i++
			dAtA[i] = uint8(f16 >> 56)
			i++
		}
	}
	if m.EDep != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDep))))
	}
	if m.Time != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if m.Mc != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Mc.Size()))
		n17, err := m.Mc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.P)*4))
		for _, num := range m.P {
			f18 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f18)
			i++
			dAtA[i] = uint8(f18 >> 8)
			i++
			dAtA[i] = uint8(f18 >> 16)
			i++
			dAtA[i] = uint8(f18 >> 24)
			i++
		}
	}
	if m.PathLength != 0 {
		dAtA[i] = 0x4d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.PathLength))))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Quality))
	}
	return i, nil
}

func (m *SimTrackerHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimTrackerHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n19, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerRawData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerRawData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Time))
	}
	if len(m.ADCs) > 0 {
		dAtA21 := make([]byte, len(m.ADCs)*10)
		var j20 int
		for _, num := range m.ADCs {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	return i, nil
}

func (m *TrackerRawDataCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerRawDataCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n22, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if len(m.Charges) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Charges)*4))
		for _, num := range m.Charges {
			f23 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f23)
			i++
			dAtA[i] = uint8(f23 >> 8)
			i++
			dAtA[i] = uint8(f23 >> 16)
			i++
			dAtA[i] = uint8(f23 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *TrackerDataCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerDataCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n24, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f25 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f25)
			i++
			dAtA[i] = uint8(f25 >> 8)
			i++
			dAtA[i] = uint8(f25 >> 16)
			i++
			dAtA[i] = uint8(f25 >> 24)
			i++
			dAtA[i] = uint8(f25 >> 32)
			i++
			dAtA[i] = uint8(f25 >> 40)
			i++
			dAtA[i] = uint8(f25 >> 48)
			i++
			dAtA[i] = uint8(f25 >> 56)
			i++
		}
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Cov)*8))
		for _, num := range m.Cov {
			f26 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f26)
			i++
			dAtA[i] = uint8(f26 >> 8)
			i++
			dAtA[i] = uint8(f26 >> 16)
			i++
			dAtA[i] = uint8(f26 >> 24)
			i++
			dAtA[i] = uint8(f26 >> 32)
			i++
			dAtA[i] = uint8(f26 >> 40)
			i++
			dAtA[i] = uint8(f26 >> 48)
			i++
			dAtA[i] = uint8(f26 >> 56)
			i++
		}
	}
	if m.EDep != 0 {
		dAtA[i] = 0x3d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDep))))
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x45
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDepErr))))
	}
	if m.Time != 0 {
		dAtA[i] = 0x4d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, msg := range m.RawHits {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n27, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerPulse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerPulse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if m.Charge != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Charge))))
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f28 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f28)
			i++
			dAtA[i] = uint8(f28 >> 8)
			i++
			dAtA[i] = uint8(f28 >> 16)
			i++
			dAtA[i] = uint8(f28 >> 24)
			i++
		}
	}
	if m.Quality != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Quality))
	}
	if m.TPC != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.TPC.Size()))
		n29, err := m.TPC.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *TrackerPulseCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerPulseCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n30, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitPlane) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitPlane) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f31 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f31)
			i++
			dAtA[i] = uint8(f31 >> 8)
			i++
			dAtA[i] = uint8(f31 >> 16)
			i++
			dAtA[i] = uint8(f31 >> 24)
			i++
			dAtA[i] = uint8(f31 >> 32)
			i++
			dAtA[i] = uint8(f31 >> 40)
			i++
			dAtA[i] = uint8(f31 >> 48)
			i++
			dAtA[i] = uint8(f31 >> 56)
			i++
		}
	}
	if len(m.U) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.U)*4))
		for _, num := range m.U {
			f32 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f32)
			i++
			dAtA[i] = uint8(f32 >> 8)
			i++
			dAtA[i] = uint8(f32 >> 16)
			i++
			dAtA[i] = uint8(f32 >> 24)
			i++
		}
	}
	if len(m.V) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.V)*4))
		for _, num := range m.V {
			f33 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f33)
			i++
			dAtA[i] = uint8(f33 >> 8)
			i++
			dAtA[i] = uint8(f33 >> 16)
			i++
			dAtA[i] = uint8(f33 >> 24)
			i++
		}
	}
	if m.DU != 0 {
		dAtA[i] = 0x45
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.DU))))
	}
	if m.DV != 0 {
		dAtA[i] = 0x4d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.DV))))
	}
	if m.EDep != 0 {
		dAtA[i] = 0x55
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDep))))
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x5d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDepErr))))
	}
	if m.Time != 0 {
		dAtA[i] = 0x65
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, msg := range m.RawHits {
			dAtA[i] = 0x72
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitPlaneCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitPlaneCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n34, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitZCylinder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitZCylinder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f35 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f35)
			i++
			dAtA[i] = uint8(f35 >> 8)
			i++
			dAtA[i] = uint8(f35 >> 16)
			i++
			dAtA[i] = uint8(f35 >> 24)
			i++
			dAtA[i] = uint8(f35 >> 32)
			i++
			dAtA[i] = uint8(f35 >> 40)
			i++
			dAtA[i] = uint8(f35 >> 48)
			i++
			dAtA[i] = uint8(f35 >> 56)
			i++
		}
	}
	if len(m.Center) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Center)*4))
		for _, num := range m.Center {
			f36 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f36)
			i++
			dAtA[i] = uint8(f36 >> 8)
			i++
			dAtA[i] = uint8(f36 >> 16)
			i++
			dAtA[i] = uint8(f36 >> 24)
			i++
		}
	}
	if m.DRPhi != 0 {
		dAtA[i] = 0x3d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.DRPhi))))
	}
	if m.DZ != 0 {
		dAtA[i] = 0x45
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.DZ))))
	}
	if m.EDep != 0 {
		dAtA[i] = 0x4d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDep))))
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x55
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EDepErr))))
	}
	if m.Time != 0 {
		dAtA[i] = 0x5d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, msg := range m.RawHits {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrackerHitZCylinderCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitZCylinderCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n37, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Track) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Track) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if m.Chi2 != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Chi2))))
	}
	if m.NDF != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.NDF))
	}
	if m.DEdx != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.DEdx))))
	}
	if m.DEdxErr != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.DEdxErr))))
	}
	if m.Radius != 0 {
		dAtA[i] = 0x3d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Radius))))
	}
	if len(m.SubDetHits) > 0 {
		dAtA39 := make([]byte, len(m.SubDetHits)*10)
		var j38 int
		for _, num1 := range m.SubDetHits {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintEicio(dAtA, i, uint64(j38))
		i += copy(dAtA[i:], dAtA39[:j38])
	}
	if len(m.States) > 0 {
		for _, msg := range m.States {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hits) > 0 {
		for _, msg := range m.Hits {
			dAtA[i] = 0x52
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tracks) > 0 {
		for _, msg := range m.Tracks {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Track_TrackState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Track_TrackState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Loc != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Loc))
	}
	if m.D0 != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.D0))))
	}
	if m.Phi != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Phi))))
	}
	if m.Omega != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Omega))))
	}
	if m.Z0 != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Z0))))
	}
	if m.TanL != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.TanL))))
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f40 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f40)
			i++
			dAtA[i] = uint8(f40 >> 8)
			i++
			dAtA[i] = uint8(f40 >> 16)
			i++
			dAtA[i] = uint8(f40 >> 24)
			i++
		}
	}
	if len(m.Ref) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Ref)*4))
		for _, num := range m.Ref {
			f41 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f41)
			i++
			dAtA[i] = uint8(f41 >> 8)
			i++
			dAtA[i] = uint8(f41 >> 16)
			i++
			dAtA[i] = uint8(f41 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *TrackCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n42, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SimCalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Params != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n43, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Energy))))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f44 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f44)
			i++
			dAtA[i] = uint8(f44 >> 8)
			i++
			dAtA[i] = uint8(f44 >> 16)
			i++
			dAtA[i] = uint8(f44 >> 24)
			i++
		}
	}
	if len(m.Contributions) > 0 {
		for _, msg := range m.Contributions {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SimCalorimeterHit_Contrib) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCalorimeterHit_Contrib) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MCParticle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.MCParticle.Size()))
		n45, err := m.MCParticle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.Energy != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Energy))))
	}
	if m.Time != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if m.PDG != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.PDG))
	}
	if len(m.StepPos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.StepPos)*4))
		for _, num := range m.StepPos {
			f46 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f46)
			i++
			dAtA[i] = uint8(f46 >> 8)
			i++
			dAtA[i] = uint8(f46 >> 16)
			i++
			dAtA[i] = uint8(f46 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *SimCalorimeterHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCalorimeterHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n47, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawCalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawCalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Amplitude != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Amplitude))
	}
	if m.TimeStamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.TimeStamp))
	}
	return i, nil
}

func (m *RawCalorimeterHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawCalorimeterHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n48, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.CellID0 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.CellID1))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Energy))))
	}
	if m.EnergyErr != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EnergyErr))))
	}
	if m.Time != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Time))))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f49 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f49)
			i++
			dAtA[i] = uint8(f49 >> 8)
			i++
			dAtA[i] = uint8(f49 >> 16)
			i++
			dAtA[i] = uint8(f49 >> 24)
			i++
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if m.Raw != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Raw.Size()))
		n50, err := m.Raw.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	return i, nil
}

func (m *CalorimeterHitCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalorimeterHitCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n51, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Energy))))
	}
	if m.EnergyErr != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.EnergyErr))))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f52 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f52)
			i++
			dAtA[i] = uint8(f52 >> 8)
			i++
			dAtA[i] = uint8(f52 >> 16)
			i++
			dAtA[i] = uint8(f52 >> 24)
			i++
		}
	}
	if len(m.PosErr) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.PosErr)*4))
		for _, num := range m.PosErr {
			f53 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f53)
			i++
			dAtA[i] = uint8(f53 >> 8)
			i++
			dAtA[i] = uint8(f53 >> 16)
			i++
			dAtA[i] = uint8(f53 >> 24)
			i++
		}
	}
	if m.Theta != 0 {
		dAtA[i] = 0x3d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Theta))))
	}
	if m.Phi != 0 {
		dAtA[i] = 0x45
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Phi))))
	}
	if len(m.DirErr) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.DirErr)*4))
		for _, num := range m.DirErr {
			f54 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f54)
			i++
			dAtA[i] = uint8(f54 >> 8)
			i++
			dAtA[i] = uint8(f54 >> 16)
			i++
			dAtA[i] = uint8(f54 >> 24)
			i++
		}
	}
	if len(m.Shape) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Shape)*4))
		for _, num := range m.Shape {
			f55 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f55)
			i++
			dAtA[i] = uint8(f55 >> 8)
			i++
			dAtA[i] = uint8(f55 >> 16)
			i++
			dAtA[i] = uint8(f55 >> 24)
			i++
		}
	}
	if len(m.PIDs) > 0 {
		for _, msg := range m.PIDs {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Clusters) > 0 {
		for _, msg := range m.Clusters {
			dAtA[i] = 0x62
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hits) > 0 {
		for _, msg := range m.Hits {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Weights) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Weights)*4))
		for _, num := range m.Weights {
			f56 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f56)
			i++
			dAtA[i] = uint8(f56 >> 8)
			i++
			dAtA[i] = uint8(f56 >> 16)
			i++
			dAtA[i] = uint8(f56 >> 24)
			i++
		}
	}
	if len(m.SubDetEnes) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.SubDetEnes)*4))
		for _, num := range m.SubDetEnes {
			f57 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f57)
			i++
			dAtA[i] = uint8(f57 >> 8)
			i++
			dAtA[i] = uint8(f57 >> 16)
			i++
			dAtA[i] = uint8(f57 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *ClusterCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n58, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RecParticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecParticle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Type))
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.P)*4))
		for _, num := range m.P {
			f59 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f59)
			i++
			dAtA[i] = uint8(f59 >> 8)
			i++
			dAtA[i] = uint8(f59 >> 16)
			i++
			dAtA[i] = uint8(f59 >> 24)
			i++
		}
	}
	if m.Energy != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Energy))))
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f60 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f60)
			i++
			dAtA[i] = uint8(f60 >> 8)
			i++
			dAtA[i] = uint8(f60 >> 16)
			i++
			dAtA[i] = uint8(f60 >> 24)
			i++
		}
	}
	if m.Mass != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Mass))))
	}
	if m.Charge != 0 {
		dAtA[i] = 0x3d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Charge))))
	}
	if len(m.Ref) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Ref)*4))
		for _, num := range m.Ref {
			f61 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f61)
			i++
			dAtA[i] = uint8(f61 >> 8)
			i++
			dAtA[i] = uint8(f61 >> 16)
			i++
			dAtA[i] = uint8(f61 >> 24)
			i++
		}
	}
	if len(m.PIDs) > 0 {
		for _, msg := range m.PIDs {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PIDUsed != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.PIDUsed))
	}
	if m.GoodnessOfPID != 0 {
		dAtA[i] = 0x5d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.GoodnessOfPID))))
	}
	if len(m.Recs) > 0 {
		for _, msg := range m.Recs {
			dAtA[i] = 0x62
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tracks) > 0 {
		for _, msg := range m.Tracks {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Clusters) > 0 {
		for _, msg := range m.Clusters {
			dAtA[i] = 0x72
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.StartVtx != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.StartVtx.Size()))
		n62, err := m.StartVtx.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}

func (m *RecParticleCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecParticleCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n63, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Vertex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vertex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Primary != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Primary))
	}
	if m.AlgType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.AlgType))
	}
	if m.Chi2 != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Chi2))))
	}
	if m.Prob != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Prob))))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f64 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f64)
			i++
			dAtA[i] = uint8(f64 >> 8)
			i++
			dAtA[i] = uint8(f64 >> 16)
			i++
			dAtA[i] = uint8(f64 >> 24)
			i++
		}
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f65 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f65)
			i++
			dAtA[i] = uint8(f65 >> 8)
			i++
			dAtA[i] = uint8(f65 >> 16)
			i++
			dAtA[i] = uint8(f65 >> 24)
			i++
		}
	}
	if len(m.Params) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEicio(dAtA, i, uint64(len(m.Params)*4))
		for _, num := range m.Params {
			f66 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f66)
			i++
			dAtA[i] = uint8(f66 >> 8)
			i++
			dAtA[i] = uint8(f66 >> 16)
			i++
			dAtA[i] = uint8(f66 >> 24)
			i++
		}
	}
	if m.RecPart != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.RecPart.Size()))
		n67, err := m.RecPart.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}

func (m *VertexCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VertexCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n68, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Relation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.From != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.From.Size()))
		n69, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.To != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.To.Size()))
		n70, err := m.To.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.Weight != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Eicio(dAtA, i, uint32(math.Float32bits(float32(m.Weight))))
	}
	return i, nil
}

func (m *RelationCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationCollection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Id))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Flags))
	}
	if m.Params != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEicio(dAtA, i, uint64(m.Params.Size()))
		n71, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEicio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Eicio(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Eicio(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintEicio(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EventHeader) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovEicio(uint64(m.Version))
	}
	if m.RunNumber != 0 {
		n += 1 + sovEicio(uint64(m.RunNumber))
	}
	if m.EventNumber != 0 {
		n += 1 + sovEicio(uint64(m.EventNumber))
	}
	if m.TimeStamp != 0 {
		n += 1 + sovEicio(uint64(m.TimeStamp))
	}
	l = len(m.Detector)
	if l > 0 {
		n += 1 + l + sovEicio(uint64(l))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.PayloadCollections) > 0 {
		for _, e := range m.PayloadCollections {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if m.NUniqueIDs != 0 {
		n += 1 + sovEicio(uint64(m.NUniqueIDs))
	}
	l = len(m.Description)
	if l > 0 {
		n += 2 + l + sovEicio(uint64(l))
	}
	return n
}

func (m *EventHeader_CollectionHeader) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEicio(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovEicio(uint64(l))
	}
	if m.PayloadSize != 0 {
		n += 1 + sovEicio(uint64(m.PayloadSize))
	}
	return n
}

func (m *IntParams) Size() (n int) {
	var l int
	_ = l
	if len(m.Array) > 0 {
		l = 0
		for _, e := range m.Array {
			l += sovEicio(uint64(e))
		}
		n += 1 + sovEicio(uint64(l)) + l
	}
	return n
}

func (m *FloatParams) Size() (n int) {
	var l int
	_ = l
	if len(m.Array) > 0 {
		n += 1 + sovEicio(uint64(len(m.Array)*4)) + len(m.Array)*4
	}
	return n
}

func (m *StringParams) Size() (n int) {
	var l int
	_ = l
	if len(m.Array) > 0 {
		for _, s := range m.Array {
			l = len(s)
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *Params) Size() (n int) {
	var l int
	_ = l
	if len(m.Ints) > 0 {
		for k, v := range m.Ints {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovEicio(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovEicio(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovEicio(uint64(mapEntrySize))
		}
	}
	if len(m.Floats) > 0 {
		for k, v := range m.Floats {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovEicio(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovEicio(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovEicio(uint64(mapEntrySize))
		}
	}
	if len(m.Strings) > 0 {
		for k, v := range m.Strings {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovEicio(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovEicio(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovEicio(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Reference) Size() (n int) {
	var l int
	_ = l
	if m.CollID != 0 {
		n += 1 + sovEicio(uint64(m.CollID))
	}
	if m.EntryID != 0 {
		n += 1 + sovEicio(uint64(m.EntryID))
	}
	return n
}

func (m *ParticleID) Size() (n int) {
	var l int
	_ = l
	if m.Likelihood != 0 {
		n += 5
	}
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if m.PDG != 0 {
		n += 1 + sovEicio(uint64(m.PDG))
	}
	if m.AlgType != 0 {
		n += 1 + sovEicio(uint64(m.AlgType))
	}
	if len(m.Params) > 0 {
		n += 1 + sovEicio(uint64(len(m.Params)*4)) + len(m.Params)*4
	}
	return n
}

func (m *MCParticle) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if len(m.Parents) > 0 {
		for _, e := range m.Parents {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if m.PDG != 0 {
		n += 1 + sovEicio(uint64(m.PDG))
	}
	if len(m.Vertex) > 0 {
		n += 1 + sovEicio(uint64(len(m.Vertex)*8)) + len(m.Vertex)*8
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.P) > 0 {
		n += 1 + sovEicio(uint64(len(m.P)*8)) + len(m.P)*8
	}
	if m.Mass != 0 {
		n += 9
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.PEndPoint) > 0 {
		n += 1 + sovEicio(uint64(len(m.PEndPoint)*8)) + len(m.PEndPoint)*8
	}
	if len(m.Spin) > 0 {
		n += 1 + sovEicio(uint64(len(m.Spin)*4)) + len(m.Spin)*4
	}
	if len(m.ColorFlow) > 0 {
		l = 0
		for _, e := range m.ColorFlow {
			l += sovEicio(uint64(e))
		}
		n += 1 + sovEicio(uint64(l)) + l
	}
	if m.GenStatus != 0 {
		n += 1 + sovEicio(uint64(m.GenStatus))
	}
	if m.SimStatus != 0 {
		n += 1 + sovEicio(uint64(m.SimStatus))
	}
	return n
}

func (m *MCParticleCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *SimTrackerHit) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Mc != nil {
		l = m.Mc.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.P) > 0 {
		n += 1 + sovEicio(uint64(len(m.P)*4)) + len(m.P)*4
	}
	if m.PathLength != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovEicio(uint64(m.Quality))
	}
	return n
}

func (m *SimTrackerHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerRawData) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 1 + sovEicio(uint64(m.Time))
	}
	if len(m.ADCs) > 0 {
		l = 0
		for _, e := range m.ADCs {
			l += sovEicio(uint64(e))
		}
		n += 1 + sovEicio(uint64(l)) + l
	}
	return n
}

func (m *TrackerRawDataCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerData) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.Charges) > 0 {
		n += 1 + sovEicio(uint64(len(m.Charges)*4)) + len(m.Charges)*4
	}
	return n
}

func (m *TrackerDataCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHit) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.Cov) > 0 {
		n += 1 + sovEicio(uint64(len(m.Cov)*8)) + len(m.Cov)*8
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovEicio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, e := range m.RawHits {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerPulse) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovEicio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if m.Quality != 0 {
		n += 1 + sovEicio(uint64(m.Quality))
	}
	if m.TPC != nil {
		l = m.TPC.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	return n
}

func (m *TrackerPulseCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitPlane) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.U) > 0 {
		n += 1 + sovEicio(uint64(len(m.U)*4)) + len(m.U)*4
	}
	if len(m.V) > 0 {
		n += 1 + sovEicio(uint64(len(m.V)*4)) + len(m.V)*4
	}
	if m.DU != 0 {
		n += 5
	}
	if m.DV != 0 {
		n += 5
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovEicio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, e := range m.RawHits {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitPlaneCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitZCylinder) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.Center) > 0 {
		n += 1 + sovEicio(uint64(len(m.Center)*4)) + len(m.Center)*4
	}
	if m.DRPhi != 0 {
		n += 5
	}
	if m.DZ != 0 {
		n += 5
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovEicio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		for _, e := range m.RawHits {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *TrackerHitZCylinderCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *Track) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if m.Chi2 != 0 {
		n += 5
	}
	if m.NDF != 0 {
		n += 1 + sovEicio(uint64(m.NDF))
	}
	if m.DEdx != 0 {
		n += 5
	}
	if m.DEdxErr != 0 {
		n += 5
	}
	if m.Radius != 0 {
		n += 5
	}
	if len(m.SubDetHits) > 0 {
		l = 0
		for _, e := range m.SubDetHits {
			l += sovEicio(uint64(e))
		}
		n += 1 + sovEicio(uint64(l)) + l
	}
	if len(m.States) > 0 {
		for _, e := range m.States {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.Hits) > 0 {
		for _, e := range m.Hits {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.Tracks) > 0 {
		for _, e := range m.Tracks {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *Track_TrackState) Size() (n int) {
	var l int
	_ = l
	if m.Loc != 0 {
		n += 1 + sovEicio(uint64(m.Loc))
	}
	if m.D0 != 0 {
		n += 5
	}
	if m.Phi != 0 {
		n += 5
	}
	if m.Omega != 0 {
		n += 5
	}
	if m.Z0 != 0 {
		n += 5
	}
	if m.TanL != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovEicio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if len(m.Ref) > 0 {
		n += 1 + sovEicio(uint64(len(m.Ref)*4)) + len(m.Ref)*4
	}
	return n
}

func (m *TrackCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *SimCalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Energy != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.Contributions) > 0 {
		for _, e := range m.Contributions {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *SimCalorimeterHit_Contrib) Size() (n int) {
	var l int
	_ = l
	if m.MCParticle != nil {
		l = m.MCParticle.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.PDG != 0 {
		n += 1 + sovEicio(uint64(m.PDG))
	}
	if len(m.StepPos) > 0 {
		n += 1 + sovEicio(uint64(len(m.StepPos)*4)) + len(m.StepPos)*4
	}
	return n
}

func (m *SimCalorimeterHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *RawCalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Amplitude != 0 {
		n += 1 + sovEicio(uint64(m.Amplitude))
	}
	if m.TimeStamp != 0 {
		n += 1 + sovEicio(uint64(m.TimeStamp))
	}
	return n
}

func (m *RawCalorimeterHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *CalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.CellID0 != 0 {
		n += 1 + sovEicio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovEicio(uint64(m.CellID1))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.EnergyErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if m.Raw != nil {
		l = m.Raw.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	return n
}

func (m *CalorimeterHitCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.EnergyErr != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.PosErr) > 0 {
		n += 1 + sovEicio(uint64(len(m.PosErr)*4)) + len(m.PosErr)*4
	}
	if m.Theta != 0 {
		n += 5
	}
	if m.Phi != 0 {
		n += 5
	}
	if len(m.DirErr) > 0 {
		n += 1 + sovEicio(uint64(len(m.DirErr)*4)) + len(m.DirErr)*4
	}
	if len(m.Shape) > 0 {
		n += 1 + sovEicio(uint64(len(m.Shape)*4)) + len(m.Shape)*4
	}
	if len(m.PIDs) > 0 {
		for _, e := range m.PIDs {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.Hits) > 0 {
		for _, e := range m.Hits {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.Weights) > 0 {
		n += 1 + sovEicio(uint64(len(m.Weights)*4)) + len(m.Weights)*4
	}
	if len(m.SubDetEnes) > 0 {
		n += 1 + sovEicio(uint64(len(m.SubDetEnes)*4)) + len(m.SubDetEnes)*4
	}
	return n
}

func (m *ClusterCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *RecParticle) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovEicio(uint64(m.Type))
	}
	if len(m.P) > 0 {
		n += 1 + sovEicio(uint64(len(m.P)*4)) + len(m.P)*4
	}
	if m.Energy != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovEicio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if m.Mass != 0 {
		n += 5
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.Ref) > 0 {
		n += 1 + sovEicio(uint64(len(m.Ref)*4)) + len(m.Ref)*4
	}
	if len(m.PIDs) > 0 {
		for _, e := range m.PIDs {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if m.PIDUsed != 0 {
		n += 1 + sovEicio(uint64(m.PIDUsed))
	}
	if m.GoodnessOfPID != 0 {
		n += 5
	}
	if len(m.Recs) > 0 {
		for _, e := range m.Recs {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.Tracks) > 0 {
		for _, e := range m.Tracks {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	if m.StartVtx != nil {
		l = m.StartVtx.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	return n
}

func (m *RecParticleCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *Vertex) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Primary != 0 {
		n += 1 + sovEicio(uint64(m.Primary))
	}
	if m.AlgType != 0 {
		n += 1 + sovEicio(uint64(m.AlgType))
	}
	if m.Chi2 != 0 {
		n += 5
	}
	if m.Prob != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovEicio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.Cov) > 0 {
		n += 1 + sovEicio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if len(m.Params) > 0 {
		n += 1 + sovEicio(uint64(len(m.Params)*4)) + len(m.Params)*4
	}
	if m.RecPart != nil {
		l = m.RecPart.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	return n
}

func (m *VertexCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func (m *Relation) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if m.Weight != 0 {
		n += 5
	}
	return n
}

func (m *RelationCollection) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEicio(uint64(m.Id))
	}
	if m.Flags != 0 {
		n += 1 + sovEicio(uint64(m.Flags))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovEicio(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovEicio(uint64(l))
		}
	}
	return n
}

func sovEicio(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEicio(x uint64) (n int) {
	return sovEicio(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunNumber", wireType)
			}
			m.RunNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunNumber |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventNumber", wireType)
			}
			m.EventNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventNumber |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			m.TimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detector = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadCollections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadCollections = append(m.PayloadCollections, &EventHeader_CollectionHeader{})
			if err := m.PayloadCollections[len(m.PayloadCollections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NUniqueIDs", wireType)
			}
			m.NUniqueIDs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NUniqueIDs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventHeader_CollectionHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			m.PayloadSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Array = append(m.Array, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Array = append(m.Array, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Array", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Array = append(m.Array, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Array = append(m.Array, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Array", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Array", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Array = append(m.Array, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ints == nil {
				m.Ints = make(map[string]*IntParams)
			}
			var mapkey string
			var mapvalue *IntParams
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEicio
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthEicio
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthEicio
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &IntParams{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEicio(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthEicio
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ints[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Floats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Floats == nil {
				m.Floats = make(map[string]*FloatParams)
			}
			var mapkey string
			var mapvalue *FloatParams
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEicio
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthEicio
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthEicio
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FloatParams{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEicio(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthEicio
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Floats[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strings == nil {
				m.Strings = make(map[string]*StringParams)
			}
			var mapkey string
			var mapvalue *StringParams
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEicio
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthEicio
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthEicio
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StringParams{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEicio(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthEicio
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Strings[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollID", wireType)
			}
			m.CollID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryID", wireType)
			}
			m.EntryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParticleID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParticleID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParticleID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Likelihood", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Likelihood = float32(math.Float32frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgType", wireType)
			}
			m.AlgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Params = append(m.Params, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Params = append(m.Params, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MCParticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MCParticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MCParticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parents = append(m.Parents, &Reference{})
			if err := m.Parents[len(m.Parents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Reference{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Vertex = append(m.Vertex, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Vertex = append(m.Vertex, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vertex", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 7:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Mass = float64(math.Float64frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Charge = float32(math.Float32frombits(v))
		case 10:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.PEndPoint = append(m.PEndPoint, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.PEndPoint = append(m.PEndPoint, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PEndPoint", wireType)
			}
		case 11:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Spin = append(m.Spin, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Spin = append(m.Spin, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Spin", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColorFlow = append(m.ColorFlow, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColorFlow = append(m.ColorFlow, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorFlow", wireType)
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenStatus", wireType)
			}
			m.GenStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimStatus", wireType)
			}
			m.SimStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SimStatus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MCParticleCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MCParticleCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MCParticleCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &MCParticle{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimTrackerHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimTrackerHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimTrackerHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDep = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mc == nil {
				m.Mc = &Reference{}
			}
			if err := m.Mc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathLength", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.PathLength = float32(math.Float32frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimTrackerHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimTrackerHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimTrackerHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &SimTrackerHit{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerRawData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerRawData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerRawData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ADCs = append(m.ADCs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ADCs = append(m.ADCs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ADCs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerRawDataCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerRawDataCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerRawDataCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TrackerRawData{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Charges = append(m.Charges, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Charges = append(m.Charges, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Charges", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerDataCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerDataCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerDataCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TrackerData{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDep = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDepErr = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawHits = append(m.RawHits, &Reference{})
			if err := m.RawHits[len(m.RawHits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TrackerHit{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerPulse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerPulse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerPulse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Charge = float32(math.Float32frombits(v))
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TPC == nil {
				m.TPC = &Reference{}
			}
			if err := m.TPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerPulseCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerPulseCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerPulseCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TrackerPulse{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitPlane) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitPlane: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitPlane: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.U = append(m.U, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.U = append(m.U, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field U", wireType)
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.V = append(m.V, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.V = append(m.V, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DU", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DU = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DV", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DV = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDep = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDepErr = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawHits = append(m.RawHits, &Reference{})
			if err := m.RawHits[len(m.RawHits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitPlaneCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitPlaneCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitPlaneCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TrackerHitPlane{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitZCylinder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitZCylinder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitZCylinder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Center = append(m.Center, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Center = append(m.Center, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Center", wireType)
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DRPhi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DRPhi = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DZ = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDep = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EDepErr = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawHits = append(m.RawHits, &Reference{})
			if err := m.RawHits[len(m.RawHits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitZCylinderCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitZCylinderCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitZCylinderCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TrackerHitZCylinder{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Track) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Track: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Track: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chi2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Chi2 = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NDF", wireType)
			}
			m.NDF = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NDF |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEdx", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DEdx = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEdxErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DEdxErr = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Radius = float32(math.Float32frombits(v))
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SubDetHits = append(m.SubDetHits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEicio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SubDetHits = append(m.SubDetHits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDetHits", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.States = append(m.States, &Track_TrackState{})
			if err := m.States[len(m.States)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hits = append(m.Hits, &Reference{})
			if err := m.Hits[len(m.Hits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tracks = append(m.Tracks, &Reference{})
			if err := m.Tracks[len(m.Tracks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Track_TrackState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loc", wireType)
			}
			m.Loc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Loc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field D0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.D0 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Phi = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Omega", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Omega = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Z0 = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TanL", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.TanL = float32(math.Float32frombits(v))
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Ref = append(m.Ref, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Ref = append(m.Ref, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Track{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimCalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimCalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Energy = float32(math.Float32frombits(v))
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contributions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contributions = append(m.Contributions, &SimCalorimeterHit_Contrib{})
			if err := m.Contributions[len(m.Contributions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCalorimeterHit_Contrib) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contrib: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contrib: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MCParticle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MCParticle == nil {
				m.MCParticle = &Reference{}
			}
			if err := m.MCParticle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Energy = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.StepPos = append(m.StepPos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.StepPos = append(m.StepPos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StepPos", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCalorimeterHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimCalorimeterHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimCalorimeterHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &SimCalorimeterHit{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawCalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawCalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawCalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amplitude", wireType)
			}
			m.Amplitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amplitude |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			m.TimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawCalorimeterHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawCalorimeterHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawCalorimeterHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &RawCalorimeterHit{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Energy = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EnergyErr = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Time = float32(math.Float32frombits(v))
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Raw == nil {
				m.Raw = &Reference{}
			}
			if err := m.Raw.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalorimeterHitCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalorimeterHitCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalorimeterHitCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &CalorimeterHit{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Energy = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.EnergyErr = float32(math.Float32frombits(v))
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.PosErr = append(m.PosErr, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.PosErr = append(m.PosErr, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PosErr", wireType)
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Theta", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Theta = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Phi = float32(math.Float32frombits(v))
		case 9:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.DirErr = append(m.DirErr, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.DirErr = append(m.DirErr, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DirErr", wireType)
			}
		case 10:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Shape = append(m.Shape, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Shape = append(m.Shape, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIDs = append(m.PIDs, &ParticleID{})
			if err := m.PIDs[len(m.PIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &Reference{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hits = append(m.Hits, &Reference{})
			if err := m.Hits[len(m.Hits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Weights = append(m.Weights, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Weights = append(m.Weights, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
		case 15:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.SubDetEnes = append(m.SubDetEnes, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.SubDetEnes = append(m.SubDetEnes, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDetEnes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Cluster{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecParticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecParticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecParticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Energy = float32(math.Float32frombits(v))
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Mass = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Charge = float32(math.Float32frombits(v))
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Ref = append(m.Ref, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Ref = append(m.Ref, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIDs = append(m.PIDs, &ParticleID{})
			if err := m.PIDs[len(m.PIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDUsed", wireType)
			}
			m.PIDUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PIDUsed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodnessOfPID", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.GoodnessOfPID = float32(math.Float32frombits(v))
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recs = append(m.Recs, &Reference{})
			if err := m.Recs[len(m.Recs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tracks = append(m.Tracks, &Reference{})
			if err := m.Tracks[len(m.Tracks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &Reference{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartVtx == nil {
				m.StartVtx = &Reference{}
			}
			if err := m.StartVtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecParticleCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecParticleCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecParticleCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &RecParticle{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vertex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vertex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vertex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			m.Primary = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Primary |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgType", wireType)
			}
			m.AlgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chi2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Chi2 = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prob", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Prob = float32(math.Float32frombits(v))
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Params = append(m.Params, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEicio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Params = append(m.Params, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecPart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecPart == nil {
				m.RecPart = &Reference{}
			}
			if err := m.RecPart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VertexCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VertexCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VertexCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Vertex{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &Reference{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &Reference{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Weight = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEicio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Relation{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEicio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEicio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEicio(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEicio
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEicio
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEicio
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEicio
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEicio(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEicio = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEicio   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("eicio.proto", fileDescriptorEicio) }

var fileDescriptorEicio = []byte{
	// 2236 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x5a, 0x4f, 0x6f, 0x1c, 0x49,
	0x15, 0xa7, 0xba, 0xe7, 0x8f, 0xe7, 0x8d, 0xc7, 0x71, 0x7a, 0xb3, 0x4e, 0xc7, 0x9b, 0x35, 0x66,
	0x58, 0x45, 0x66, 0x77, 0xf1, 0x26, 0x5e, 0x76, 0x59, 0x45, 0xe2, 0x00, 0x1e, 0x87, 0x58, 0x0a,
	0xd9, 0x51, 0x3b, 0xb6, 0x44, 0x6e, 0x95, 0xee, 0xb2, 0xa7, 0x95, 0x9e, 0xee, 0xde, 0xee, 0x1a,
	0x3b, 0x8e, 0x90, 0xb8, 0xa0, 0xfd, 0x00, 0x80, 0x56, 0x41, 0x42, 0x2b, 0x84, 0x10, 0x87, 0x95,
	0xe0, 0x5b, 0x20, 0x21, 0x71, 0xe1, 0xc0, 0x01, 0x6e, 0x28, 0x1c, 0x91, 0xf8, 0x06, 0x48, 0xa8,
	0x5e, 0x55, 0x75, 0x75, 0x8f, 0x7b, 0x6c, 0x0b, 0xed, 0x64, 0x2f, 0x71, 0xbd, 0xaa, 0x57, 0x35,
	0xaf, 0x7e, 0xbf, 0xf7, 0xa7, 0xaa, 0x3a, 0xd0, 0x65, 0xa1, 0x1f, 0x26, 0x9b, 0x69, 0x96, 0xf0,
	0xc4, 0x51, 0xc2, 0x38, 0x09, 0x58, 0xd4, 0xff, 0x87, 0x0d, 0xdd, 0x9d, 0x63, 0x16, 0xf3, 0xfb,
	0x8c, 0x06, 0x2c, 0x73, 0x5c, 0x68, 0x1f, 0xb3, 0x2c, 0x0f, 0x93, 0xd8, 0x25, 0xeb, 0x64, 0xa3,
	0xe7, 0x69, 0xd1, 0xb9, 0x09, 0x9d, 0x6c, 0x12, 0x3f, 0x9c, 0x8c, 0x9f, 0xb0, 0xcc, 0xb5, 0xd6,
	0xc9, 0x46, 0xc3, 0x33, 0x1d, 0xce, 0x3a, 0x74, 0x99, 0x58, 0x46, 0x8d, 0xdb, 0x38, 0x5e, 0xee,
	0x12, 0xf3, 0x79, 0x38, 0x66, 0x7b, 0x9c, 0x8e, 0x53, 0xb7, 0x21, 0xe7, 0x17, 0x1d, 0xce, 0x2a,
	0x2c, 0x04, 0x8c, 0x33, 0x9f, 0x27, 0x99, 0xdb, 0x5c, 0x27, 0x1b, 0x1d, 0xaf, 0x90, 0x9d, 0x77,
	0xa0, 0x95, 0xd2, 0x8c, 0x8e, 0x73, 0xb7, 0xb5, 0x4e, 0x36, 0xba, 0x5b, 0xaf, 0x6d, 0x96, 0x76,
	0xb0, 0x39, 0xc4, 0x21, 0x4f, 0xa9, 0x38, 0x3f, 0x06, 0x27, 0xa5, 0xa7, 0x51, 0x42, 0x83, 0xed,
	0x24, 0x8a, 0x98, 0xcf, 0xc3, 0x24, 0xce, 0xdd, 0xf6, 0xba, 0xbd, 0xd1, 0xdd, 0xfa, 0x56, 0x65,
	0x62, 0x69, 0xdb, 0x9b, 0x46, 0x57, 0x76, 0x78, 0x35, 0x8b, 0x38, 0x6b, 0x00, 0xf1, 0x7e, 0x1c,
	0x7e, 0x32, 0x61, 0xbb, 0x83, 0xdc, 0x5d, 0x40, 0x78, 0x4a, 0x3d, 0x02, 0x83, 0x80, 0xe5, 0x7e,
	0x16, 0xa6, 0x42, 0xdf, 0x5d, 0xc6, 0x6d, 0x94, 0xbb, 0x56, 0x23, 0x58, 0x9e, 0xfe, 0x25, 0xc7,
	0x81, 0x46, 0x4c, 0xc7, 0x0c, 0xe1, 0xee, 0x78, 0xd8, 0x76, 0x96, 0xc0, 0x0a, 0x03, 0x04, 0xb9,
	0xe7, 0x59, 0x61, 0x20, 0x74, 0xf8, 0x69, 0xca, 0x10, 0xd6, 0x8e, 0x87, 0x6d, 0xf1, 0x6b, 0xca,
	0xc6, 0xbd, 0xf0, 0x39, 0x43, 0x44, 0x7b, 0x5e, 0xb9, 0xab, 0xff, 0x0d, 0xe8, 0xec, 0xc6, 0x5c,
	0xe2, 0xe3, 0x5c, 0x83, 0x26, 0xcd, 0x32, 0x7a, 0xea, 0x92, 0x75, 0x7b, 0xa3, 0xe9, 0x49, 0xa1,
	0xff, 0x4d, 0xe8, 0xde, 0x8b, 0x12, 0x5a, 0xab, 0x64, 0x69, 0xa5, 0xb7, 0x60, 0x71, 0x8f, 0x67,
	0x61, 0x7c, 0x54, 0xa7, 0xd5, 0xd1, 0x5a, 0x7f, 0xb0, 0xa1, 0xa5, 0x14, 0xee, 0x40, 0x23, 0x8c,
	0x79, 0x8e, 0xe3, 0xdd, 0xad, 0x37, 0x6b, 0xe8, 0xda, 0xdc, 0x8d, 0x79, 0xbe, 0x13, 0xf3, 0xec,
	0xd4, 0x43, 0x55, 0xe7, 0xbb, 0xd0, 0x3a, 0x14, 0x86, 0xe4, 0xae, 0x85, 0x93, 0xbe, 0x5e, 0x37,
	0x09, 0x4d, 0x55, 0xd3, 0x94, 0xba, 0x73, 0x17, 0xda, 0x39, 0x1a, 0x97, 0xbb, 0x36, 0xce, 0x5c,
	0xaf, 0x9b, 0x29, 0xed, 0x57, 0x53, 0xf5, 0x84, 0xd5, 0x8f, 0x11, 0x20, 0xd9, 0xeb, 0x2c, 0x83,
	0xfd, 0x94, 0x9d, 0x2a, 0x1a, 0x44, 0xd3, 0x79, 0x17, 0x9a, 0xc7, 0x34, 0x9a, 0x30, 0x24, 0xa2,
	0xbb, 0xb5, 0x52, 0x59, 0xb8, 0x40, 0xd6, 0x93, 0x4a, 0x77, 0xad, 0x8f, 0xc8, 0xea, 0x9e, 0x82,
	0x73, 0xe6, 0x92, 0x9b, 0xd5, 0x25, 0xdd, 0xca, 0x92, 0x25, 0x26, 0xca, 0x8b, 0xee, 0x6b, 0xf8,
	0x67, 0xae, 0xfa, 0x5e, 0x75, 0xd5, 0x1b, 0x95, 0x55, 0xcb, 0xd4, 0x95, 0x96, 0xed, 0x7f, 0x0f,
	0x3a, 0x1e, 0x3b, 0x64, 0x19, 0x8b, 0x7d, 0xe6, 0xac, 0x40, 0xcb, 0x4f, 0xa2, 0x68, 0x77, 0xa0,
	0xa2, 0x5e, 0x49, 0x22, 0x1d, 0x30, 0xf1, 0xa3, 0xbb, 0x03, 0xe5, 0x8d, 0x5a, 0xec, 0xff, 0x8c,
	0x00, 0x0c, 0x69, 0xc6, 0x43, 0x3f, 0x62, 0xbb, 0x03, 0x11, 0x1b, 0x51, 0xf8, 0x94, 0x45, 0xe1,
	0x28, 0x49, 0x02, 0x5c, 0xc4, 0xf2, 0x4a, 0x3d, 0x85, 0x07, 0x8b, 0x55, 0x9a, 0xca, 0x83, 0x97,
	0xc1, 0x1e, 0x0e, 0x7e, 0x88, 0x4e, 0xdd, 0xf4, 0x44, 0x53, 0xfc, 0x1c, 0x8d, 0x8e, 0x1e, 0x09,
	0xc5, 0x06, 0xf6, 0x6a, 0x51, 0x18, 0xa8, 0x72, 0x40, 0x13, 0x5d, 0x53, 0x49, 0xfd, 0x4f, 0x6d,
	0x80, 0x1f, 0x6d, 0x6b, 0x43, 0x54, 0xe0, 0x90, 0x22, 0x70, 0x6e, 0x43, 0x3b, 0xa5, 0x19, 0x8b,
	0x0b, 0xbf, 0xaa, 0x92, 0x58, 0x00, 0xe0, 0x69, 0x35, 0x67, 0x0b, 0x16, 0xfc, 0x51, 0x18, 0x05,
	0x19, 0x8b, 0x95, 0x43, 0xcd, 0x9a, 0x52, 0xe8, 0xe9, 0x8d, 0x34, 0xcc, 0x46, 0x56, 0xa0, 0x75,
	0xcc, 0x32, 0xce, 0x9e, 0xa1, 0xb9, 0xc4, 0x53, 0x12, 0xc2, 0x10, 0x8e, 0x19, 0x26, 0x32, 0xcb,
	0xc3, 0xb6, 0xb3, 0x08, 0x24, 0xc5, 0x04, 0x45, 0x3c, 0x92, 0x0a, 0x8d, 0x31, 0xcd, 0x65, 0x7a,
	0x21, 0x1e, 0xb6, 0x91, 0x9d, 0x11, 0xcd, 0x8e, 0x98, 0xdb, 0xc1, 0x79, 0x4a, 0x12, 0x29, 0x75,
	0xb8, 0x13, 0x07, 0xc3, 0x24, 0x8c, 0xb9, 0x0b, 0xb8, 0x82, 0xe9, 0x10, 0x2b, 0xe5, 0x69, 0x18,
	0xbb, 0x5d, 0x04, 0x0c, 0xdb, 0x62, 0x86, 0x9f, 0x44, 0x49, 0x76, 0x2f, 0x4a, 0x4e, 0xdc, 0x45,
	0xcc, 0x04, 0xa6, 0x43, 0x8c, 0x1e, 0xb1, 0x78, 0x8f, 0x53, 0x3e, 0xc9, 0xdd, 0x1e, 0xee, 0xc6,
	0x74, 0x88, 0xd1, 0x3c, 0x1c, 0xab, 0xd1, 0x25, 0x84, 0xd8, 0x74, 0xf4, 0x7f, 0x4d, 0xe0, 0x9a,
	0x21, 0xc2, 0x64, 0xb9, 0x33, 0x94, 0x5c, 0x83, 0xe6, 0x61, 0x44, 0x8f, 0x72, 0xe5, 0x50, 0x52,
	0x28, 0xe5, 0x78, 0xfb, 0xe2, 0x1c, 0x7f, 0x47, 0x7a, 0x65, 0xc8, 0x72, 0xb7, 0x81, 0x14, 0x5d,
	0xaf, 0x68, 0x1b, 0x33, 0x3c, 0xad, 0xd7, 0xff, 0x2f, 0x81, 0xde, 0x5e, 0x38, 0x7e, 0x94, 0x51,
	0xff, 0x29, 0xcb, 0xee, 0x87, 0xfc, 0x8c, 0x5d, 0x2e, 0xb4, 0x7d, 0x26, 0x9c, 0xfe, 0xb6, 0x72,
	0x52, 0x2d, 0x9a, 0x91, 0x3b, 0xca, 0x57, 0xb5, 0x28, 0x88, 0x4f, 0x13, 0x69, 0x04, 0xf1, 0x44,
	0x53, 0x80, 0xbe, 0x33, 0x60, 0x29, 0xd6, 0x30, 0xcb, 0xc3, 0x76, 0x2d, 0xe9, 0xb7, 0xc0, 0x1a,
	0xfb, 0x6e, 0xbb, 0x26, 0xb1, 0x18, 0x07, 0xb3, 0xc6, 0xbe, 0x74, 0x8e, 0x05, 0x64, 0x90, 0xa4,
	0x22, 0xca, 0x52, 0xca, 0x47, 0x0f, 0x58, 0x7c, 0xc4, 0x47, 0xca, 0x19, 0x4a, 0x3d, 0xc2, 0xd2,
	0x4f, 0x26, 0x34, 0x0a, 0xf9, 0xa9, 0x0b, 0xd2, 0x52, 0x25, 0xf6, 0x7f, 0x4b, 0xe0, 0x7a, 0x65,
	0xff, 0xf3, 0x65, 0xe8, 0x3b, 0xd3, 0x0c, 0xad, 0x56, 0x73, 0x52, 0xd9, 0x12, 0x43, 0xd2, 0x4f,
	0x60, 0x49, 0x75, 0x7b, 0xf4, 0x64, 0x40, 0x39, 0xfd, 0x52, 0x48, 0xd2, 0xf0, 0x37, 0x54, 0xea,
	0x11, 0xf0, 0x3b, 0xd0, 0xf8, 0xfe, 0x60, 0x5b, 0x26, 0x93, 0x9e, 0x87, 0xed, 0xfe, 0xef, 0x08,
	0xb8, 0xd5, 0x9f, 0x9f, 0x2f, 0x46, 0x1f, 0x4c, 0x63, 0xf4, 0x46, 0x45, 0xbb, 0x6a, 0x8a, 0x01,
	0xe9, 0xa7, 0xd0, 0x55, 0x43, 0x73, 0x41, 0x48, 0x3b, 0xa8, 0xd0, 0xc6, 0x2c, 0xa3, 0x33, 0xae,
	0x16, 0xfb, 0x9f, 0x13, 0x78, 0xbd, 0x64, 0xc1, 0x7c, 0x41, 0xda, 0x9a, 0x06, 0xc9, 0xad, 0x03,
	0xa9, 0x8a, 0xd0, 0x67, 0x16, 0xc0, 0x97, 0x1c, 0xe8, 0xba, 0x7c, 0x35, 0xaa, 0xe5, 0x4b, 0x04,
	0x7f, 0xd3, 0x04, 0xff, 0x32, 0xd8, 0x7e, 0x72, 0xec, 0xb6, 0x64, 0x8f, 0x9f, 0x1c, 0x17, 0xe9,
	0xa0, 0x5d, 0x4a, 0x07, 0x2e, 0xb4, 0xc5, 0xdf, 0x9d, 0x2c, 0xc3, 0x24, 0x6f, 0x79, 0x5a, 0x2c,
	0x78, 0xe8, 0x54, 0x79, 0xa8, 0x0f, 0x69, 0x51, 0xdb, 0x32, 0x7a, 0x72, 0x3f, 0xe4, 0x39, 0xa6,
	0xf8, 0x73, 0x6a, 0x9b, 0x52, 0xc3, 0x1c, 0xfd, 0xaa, 0x32, 0xc0, 0x05, 0x39, 0xba, 0x2e, 0xfc,
	0xff, 0x46, 0x60, 0x51, 0xf5, 0x0f, 0x27, 0x51, 0xce, 0xe6, 0xe6, 0xdb, 0xa6, 0x9e, 0x36, 0x2b,
	0xf5, 0xb4, 0xc4, 0x9f, 0x25, 0xf9, 0x2b, 0xa1, 0xdf, 0xae, 0xa2, 0xbf, 0x01, 0xf6, 0xa3, 0xe1,
	0x36, 0x32, 0x38, 0x1b, 0x79, 0xa1, 0xd2, 0xff, 0x0d, 0x81, 0x95, 0xf2, 0xb6, 0xe6, 0x8b, 0xfb,
	0xfb, 0xd3, 0xb8, 0xdf, 0xa8, 0xc3, 0x1d, 0x0d, 0x31, 0xc8, 0xff, 0xc9, 0x82, 0x2b, 0x86, 0x91,
	0x61, 0x44, 0x63, 0xf6, 0x0a, 0xc3, 0x66, 0x11, 0xc8, 0xbe, 0x02, 0x9d, 0xec, 0x0b, 0xe9, 0x00,
	0x8f, 0x43, 0x96, 0x47, 0x0e, 0x84, 0x15, 0xc1, 0xbe, 0x8a, 0x13, 0x2b, 0xd8, 0x47, 0xf9, 0x40,
	0x05, 0x88, 0x15, 0x1c, 0x14, 0x01, 0x06, 0xf5, 0x01, 0xd6, 0xad, 0x0f, 0xb0, 0xc5, 0xfa, 0x00,
	0xeb, 0xcd, 0x0c, 0xb0, 0xa5, 0xcb, 0x05, 0xd8, 0xef, 0x09, 0xdc, 0x98, 0xc2, 0x71, 0xbe, 0x6c,
	0x7f, 0x38, 0xcd, 0xf6, 0xcd, 0x19, 0x51, 0x86, 0xb6, 0x18, 0xc2, 0xff, 0x62, 0xc1, 0x6b, 0x66,
	0xf0, 0xf1, 0xf6, 0x69, 0x14, 0xc6, 0xe2, 0x32, 0xfa, 0xea, 0x48, 0x17, 0x31, 0xc8, 0x62, 0xce,
	0x32, 0xc5, 0xbc, 0x92, 0x04, 0x28, 0x81, 0x37, 0x1c, 0x85, 0x2a, 0x65, 0x4a, 0x01, 0x69, 0x7f,
	0x5c, 0xb8, 0xc1, 0xe3, 0x82, 0xf6, 0x4e, 0x3d, 0xed, 0x50, 0x4f, 0x7b, 0xb7, 0x9e, 0xf6, 0xc5,
	0x99, 0xb4, 0xf7, 0x2e, 0x47, 0xfb, 0x1f, 0x09, 0xbc, 0x59, 0x83, 0xe6, 0x7c, 0xa9, 0xbf, 0x3b,
	0x4d, 0xfd, 0xfa, 0x0c, 0xea, 0x0b, 0x7b, 0x0c, 0xfd, 0xff, 0xb6, 0xa1, 0x89, 0x0a, 0x67, 0x0c,
	0xab, 0xbb, 0xa7, 0x39, 0xd0, 0xf0, 0x47, 0xe1, 0x16, 0x1a, 0x65, 0x79, 0xd8, 0x16, 0x84, 0x3e,
	0x1c, 0xdc, 0xd3, 0x57, 0x9e, 0x87, 0x83, 0x7b, 0x42, 0x2b, 0xd8, 0x09, 0x9e, 0xe9, 0x93, 0xaf,
	0x68, 0x0b, 0x90, 0xc5, 0x5f, 0x41, 0x89, 0x3c, 0xfc, 0x6a, 0x51, 0xd0, 0x9f, 0xd1, 0x20, 0x9c,
	0xe4, 0x8a, 0x67, 0x25, 0x89, 0x13, 0x6e, 0x3e, 0x79, 0x32, 0x60, 0x1c, 0xf1, 0x5f, 0xc0, 0x1b,
	0x4a, 0xa9, 0xc7, 0xf9, 0x00, 0x5a, 0x39, 0xa7, 0x9c, 0xe5, 0x6e, 0xa7, 0xe6, 0x71, 0x01, 0xf7,
	0x24, 0xff, 0x15, 0xd7, 0x12, 0xe6, 0x29, 0x65, 0xe7, 0x6d, 0x68, 0x8c, 0xc4, 0x82, 0x70, 0x2e,
	0xa1, 0xa8, 0xe3, 0x6c, 0x42, 0x8b, 0x8b, 0x15, 0x2e, 0x2a, 0xab, 0x4a, 0x6b, 0xf5, 0x73, 0xa2,
	0x8e, 0x1b, 0xf8, 0x93, 0x02, 0x99, 0x28, 0xf1, 0x11, 0xd2, 0xa6, 0x27, 0x9a, 0xe8, 0xbc, 0x32,
	0x7e, 0x84, 0xf3, 0xde, 0xc6, 0x60, 0x18, 0x85, 0x0a, 0x4e, 0xd1, 0x14, 0xee, 0x90, 0x8c, 0xd9,
	0x11, 0x55, 0x55, 0x4a, 0x0a, 0x62, 0xde, 0xf3, 0xdb, 0x0a, 0x4f, 0xeb, 0xf9, 0x6d, 0xe4, 0x86,
	0xc6, 0x0f, 0x8a, 0x7b, 0x04, 0x8d, 0x1f, 0xe8, 0x92, 0xd5, 0x36, 0x25, 0x6b, 0x19, 0xec, 0x8c,
	0x1d, 0xaa, 0x3b, 0x83, 0x68, 0xf6, 0x7f, 0x4e, 0x54, 0x76, 0x9f, 0xaf, 0x43, 0xbe, 0x3b, 0xed,
	0x90, 0xce, 0x59, 0x6e, 0x8c, 0x0b, 0xbe, 0xb0, 0xe1, 0xea, 0x5e, 0x38, 0xde, 0xa6, 0x51, 0x92,
	0x85, 0x63, 0xc6, 0xeb, 0xcf, 0x6a, 0xc6, 0x00, 0xeb, 0x62, 0x03, 0x4a, 0xc9, 0xca, 0x9e, 0x99,
	0xac, 0x1a, 0xd5, 0x64, 0xb5, 0x02, 0x2d, 0x16, 0xb3, 0xec, 0xe8, 0x54, 0x1f, 0x05, 0xa4, 0xa4,
	0x13, 0x96, 0x3a, 0x0a, 0x88, 0x84, 0xf5, 0x00, 0x7a, 0x7e, 0x22, 0x8c, 0x7f, 0x32, 0x29, 0xbf,
	0x29, 0xde, 0x9a, 0xbe, 0xd8, 0x54, 0x77, 0xb4, 0xb9, 0x2d, 0xe7, 0x78, 0xd5, 0xc9, 0xab, 0xbf,
	0x22, 0xd0, 0x56, 0x43, 0xce, 0x87, 0xe5, 0x27, 0x0c, 0xdc, 0xfc, 0x6c, 0xa7, 0x2b, 0x3f, 0x76,
	0x18, 0xdb, 0xad, 0x8a, 0xed, 0x3a, 0xdd, 0xd9, 0xa5, 0x74, 0x77, 0xf6, 0x89, 0xc2, 0x85, 0x76,
	0xce, 0x59, 0x3a, 0x4c, 0x8a, 0x03, 0xbe, 0x12, 0xfb, 0x5f, 0x10, 0x78, 0xe3, 0xcc, 0x46, 0xe6,
	0xeb, 0x3b, 0x1f, 0x4d, 0xfb, 0xce, 0xda, 0xf9, 0xb0, 0x1a, 0x3f, 0xfa, 0x05, 0x81, 0xab, 0x1e,
	0x3d, 0xb9, 0xc0, 0x8f, 0xfe, 0x9f, 0x3a, 0x76, 0x13, 0x3a, 0x74, 0x9c, 0x46, 0x21, 0x9f, 0x04,
	0xba, 0x98, 0x99, 0x8e, 0xea, 0x73, 0x76, 0x53, 0x8e, 0x16, 0x1d, 0x08, 0xe1, 0x19, 0xab, 0xbe,
	0x52, 0x08, 0xcf, 0x58, 0x63, 0x20, 0xfc, 0x0f, 0x81, 0xa5, 0x39, 0xe0, 0x67, 0xdc, 0xb3, 0x51,
	0x71, 0xcf, 0x9b, 0xd0, 0x91, 0x2d, 0x51, 0x16, 0x64, 0xd4, 0x99, 0x8e, 0xda, 0xc7, 0x12, 0x15,
	0x8c, 0x6d, 0x13, 0x8c, 0xba, 0x4c, 0x2d, 0x94, 0xca, 0xd4, 0x06, 0xd8, 0x19, 0x3d, 0xc1, 0x23,
	0xc1, 0x39, 0x27, 0xf2, 0x8c, 0x9e, 0xe0, 0x4d, 0xff, 0x55, 0x52, 0x73, 0xc1, 0x4d, 0x7f, 0x16,
	0x2f, 0x5f, 0xd8, 0xd0, 0xde, 0x8e, 0x26, 0x39, 0xaf, 0x39, 0x98, 0xd5, 0xd5, 0x69, 0x03, 0xb8,
	0x3d, 0x1b, 0xf0, 0xc6, 0x34, 0xe0, 0xa5, 0xa3, 0x99, 0x55, 0x1c, 0xcd, 0xd2, 0x24, 0x97, 0x45,
	0x5b, 0xbe, 0xb5, 0xa2, 0x24, 0x90, 0xe0, 0x23, 0xc6, 0xa9, 0x3e, 0x9a, 0xa1, 0xa0, 0xab, 0xd9,
	0x82, 0xa9, 0x66, 0x2b, 0xd0, 0x0a, 0xc2, 0x4c, 0xcc, 0xef, 0xc8, 0xf9, 0x52, 0x12, 0xf3, 0xf3,
	0x11, 0x4d, 0x19, 0x56, 0x61, 0xcb, 0x93, 0x82, 0xf3, 0x0e, 0x34, 0x86, 0xbb, 0x03, 0x5d, 0x6c,
	0xaf, 0x4f, 0xe3, 0xa8, 0x1e, 0x98, 0x3d, 0x54, 0xc2, 0xd7, 0x59, 0x89, 0x48, 0x8e, 0xcf, 0x97,
	0xe7, 0xbd, 0xce, 0x2a, 0xbd, 0xa2, 0xf6, 0xf7, 0x2e, 0x51, 0xfb, 0x5d, 0x68, 0x9f, 0xb0, 0xf0,
	0x68, 0xa4, 0x8e, 0xfc, 0x96, 0xa7, 0x45, 0x73, 0x30, 0xd9, 0x89, 0x59, 0xee, 0x5e, 0xc1, 0xc1,
	0x52, 0x4f, 0xff, 0x33, 0x02, 0x57, 0x15, 0x59, 0xf3, 0x75, 0xa6, 0xcd, 0x69, 0x67, 0xba, 0x56,
	0x75, 0x26, 0x69, 0x83, 0xf1, 0xa2, 0xbf, 0xdb, 0xd0, 0xf5, 0x98, 0x3f, 0xf3, 0x89, 0xbc, 0xce,
	0x93, 0xf0, 0xd5, 0xd1, 0xd6, 0xaf, 0x8e, 0xb3, 0x02, 0x59, 0x9d, 0x3d, 0x9a, 0xe6, 0xec, 0xa1,
	0x1f, 0xaf, 0x55, 0xf0, 0x4e, 0x3d, 0x5e, 0xb7, 0xa7, 0x2f, 0xdb, 0xd5, 0x73, 0x4a, 0xe1, 0x09,
	0x9d, 0xcb, 0x78, 0x82, 0x0b, 0xed, 0xe1, 0xee, 0x60, 0x3f, 0x67, 0x81, 0x7e, 0x17, 0x51, 0xa2,
	0xf3, 0x16, 0xf4, 0x8e, 0x92, 0x24, 0x88, 0x59, 0x9e, 0x7f, 0x7c, 0x38, 0xdc, 0x1d, 0xa8, 0x63,
	0x7f, 0xb5, 0x53, 0x78, 0x45, 0xc6, 0xfc, 0x8b, 0xbc, 0x08, 0x75, 0x4a, 0x27, 0xc2, 0xde, 0x65,
	0x4e, 0x84, 0x15, 0x2f, 0x5d, 0xba, 0xa4, 0x97, 0x6e, 0xc1, 0x42, 0xce, 0x69, 0xc6, 0x0f, 0xf8,
	0x33, 0xf7, 0xca, 0xb9, 0x29, 0xac, 0xd0, 0xc3, 0x97, 0xb8, 0x12, 0xb5, 0x5f, 0xe9, 0x4b, 0x5c,
	0xc9, 0x0e, 0xe3, 0x7b, 0x2f, 0x09, 0xb4, 0x0e, 0xe4, 0x97, 0x8f, 0x9a, 0x8a, 0x92, 0x66, 0xe1,
	0x98, 0x66, 0xa7, 0xba, 0xa2, 0x28, 0xb1, 0xfc, 0x11, 0xc8, 0xae, 0x7e, 0x04, 0xd2, 0x17, 0x91,
	0x46, 0xe9, 0x22, 0xe2, 0x40, 0x23, 0xcd, 0x92, 0x27, 0xfa, 0xda, 0x21, 0xda, 0x35, 0x87, 0xb7,
	0xb3, 0xc7, 0x64, 0xf3, 0x41, 0x69, 0xa1, 0xfc, 0x41, 0x09, 0x6f, 0x7f, 0x72, 0x2b, 0x17, 0x54,
	0x12, 0xad, 0xd6, 0xff, 0x25, 0x81, 0x65, 0xb9, 0xc9, 0xf9, 0x12, 0xf0, 0xed, 0x69, 0x02, 0xaa,
	0xda, 0xd2, 0x04, 0x83, 0xfd, 0xa7, 0x04, 0x16, 0x3c, 0x16, 0xd1, 0x5a, 0x73, 0xde, 0x86, 0xc6,
	0x61, 0x96, 0x8c, 0x6b, 0xbf, 0x6c, 0x96, 0xbc, 0x5f, 0xe8, 0x38, 0xb7, 0xc0, 0xe2, 0x89, 0x32,
	0x70, 0xe6, 0xa7, 0x0a, 0x9e, 0x08, 0x44, 0x65, 0xb2, 0xd4, 0x69, 0x42, 0x4a, 0xfd, 0x17, 0x04,
	0x1c, 0x6d, 0xc8, 0x7c, 0x11, 0x7a, 0x6f, 0x1a, 0xa1, 0xd7, 0xa7, 0xcc, 0x95, 0x46, 0x14, 0x18,
	0xfd, 0xe0, 0xfa, 0x9f, 0x5f, 0xae, 0x91, 0xbf, 0xbe, 0x5c, 0x23, 0xff, 0x7c, 0xb9, 0x46, 0x5e,
	0xfc, 0x6b, 0xed, 0x6b, 0x8f, 0x9b, 0xa8, 0xfa, 0xa4, 0x85, 0xff, 0x55, 0xe2, 0xfd, 0xff, 0x05,
	0x00, 0x00, 0xff, 0xff, 0x21, 0x03, 0x1f, 0x9c, 0x39, 0x21, 0x00, 0x00,
}

// Extra generated functions for compliance with Message and Collection interfaces

func (c *MCParticleCollection) SetId(id uint32) {
	c.Id = id
}

func (c *MCParticleCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *MCParticleCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *SimTrackerHitCollection) SetId(id uint32) {
	c.Id = id
}

func (c *SimTrackerHitCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *SimTrackerHitCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackerRawDataCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackerRawDataCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackerRawDataCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackerDataCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackerDataCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackerDataCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackerHitCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackerHitCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackerHitCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackerPulseCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackerPulseCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackerPulseCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackerHitPlaneCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackerHitPlaneCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackerHitPlaneCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackerHitZCylinderCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackerHitZCylinderCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackerHitZCylinderCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *TrackCollection) SetId(id uint32) {
	c.Id = id
}

func (c *TrackCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *TrackCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *SimCalorimeterHitCollection) SetId(id uint32) {
	c.Id = id
}

func (c *SimCalorimeterHitCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *SimCalorimeterHitCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *RawCalorimeterHitCollection) SetId(id uint32) {
	c.Id = id
}

func (c *RawCalorimeterHitCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *RawCalorimeterHitCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *CalorimeterHitCollection) SetId(id uint32) {
	c.Id = id
}

func (c *CalorimeterHitCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *CalorimeterHitCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *ClusterCollection) SetId(id uint32) {
	c.Id = id
}

func (c *ClusterCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *ClusterCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *RecParticleCollection) SetId(id uint32) {
	c.Id = id
}

func (c *RecParticleCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *RecParticleCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *VertexCollection) SetId(id uint32) {
	c.Id = id
}

func (c *VertexCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *VertexCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (c *RelationCollection) SetId(id uint32) {
	c.Id = id
}

func (c *RelationCollection) GetNEntries() uint32 {
	return uint32(len(c.Entries))
}

func (c *RelationCollection) GetEntry(i uint32) proto.Message {
	if i < uint32(len(c.Entries)) {
		return c.Entries[i]
	}
	return nil
}

func (m *MCParticle) SetId(id uint32) {
	m.Id = id
}

func (m *SimTrackerHit) SetId(id uint32) {
	m.Id = id
}

func (m *TrackerRawData) SetId(id uint32) {
	m.Id = id
}

func (m *TrackerData) SetId(id uint32) {
	m.Id = id
}

func (m *TrackerHit) SetId(id uint32) {
	m.Id = id
}

func (m *TrackerPulse) SetId(id uint32) {
	m.Id = id
}

func (m *TrackerHitPlane) SetId(id uint32) {
	m.Id = id
}

func (m *TrackerHitZCylinder) SetId(id uint32) {
	m.Id = id
}

func (m *Track) SetId(id uint32) {
	m.Id = id
}

func (m *SimCalorimeterHit) SetId(id uint32) {
	m.Id = id
}

func (m *RawCalorimeterHit) SetId(id uint32) {
	m.Id = id
}

func (m *CalorimeterHit) SetId(id uint32) {
	m.Id = id
}

func (m *Cluster) SetId(id uint32) {
	m.Id = id
}

func (m *RecParticle) SetId(id uint32) {
	m.Id = id
}

func (m *Vertex) SetId(id uint32) {
	m.Id = id
}

func (m *Relation) SetId(id uint32) {
	m.Id = id
}
